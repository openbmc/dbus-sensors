{
  "comments": [
    {
      "key": {
        "uuid": "c5b0fca8_db3defc0",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-11-17T17:48:35Z",
      "side": 1,
      "message": "This doesn\u0027t need to be a shared_ptr.",
      "range": {
        "startLine": 40,
        "startChar": 3,
        "endLine": 40,
        "endChar": 20
      },
      "revId": "8473a46fa21d720929b57cb664f89753adc772d9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7c02886_47c1bc83",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-19T09:33:48Z",
      "side": 1,
      "message": "Doing a final confirmation before I make the change.\nAs per boost(https://www.boost.org/doc/libs/1_77_0/doc/html/boost_asio/reference/async_read_until/overload1.html) the async_read_until buffer definition says as\n\n\"The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.\"\n\nAre we sure, even if the class(readBuf) is destructed before the handler is called, it will not create any issue, since we validate the weak_ptr to the class in the handler first.\n@Zhikui \u0026 @Ed to confirm.",
      "parentUuid": "c5b0fca8_db3defc0",
      "range": {
        "startLine": 40,
        "startChar": 3,
        "endLine": 40,
        "endChar": 20
      },
      "revId": "8473a46fa21d720929b57cb664f89753adc772d9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c533d20f_cd1a07d2",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-11-19T17:31:15Z",
      "side": 1,
      "message": "Re-read the docs, to me, it implies the buffer is being accessed under the hood until delimiter or error is received, then handler gets called in this process. So I am not 100% sure that we can cancel the underlining usage before destruction. The destructor does cancel timer, but that does not cancel async_read_until in progress. Only when handler is called, we know the buffer ownership is back to the caller, i.e. sensor process.\nSo I think shared_ptr may still be needed here.",
      "parentUuid": "e7c02886_47c1bc83",
      "range": {
        "startLine": 40,
        "startChar": 3,
        "endLine": 40,
        "endChar": 20
      },
      "revId": "8473a46fa21d720929b57cb664f89753adc772d9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "284f1394_e82d36db",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-11-19T19:39:28Z",
      "side": 1,
      "message": "\u003e Re-read the docs, to me, it implies the buffer is being accessed under the hood until delimiter or error is received, then handler gets called in this process. So I am not 100% sure that we can cancel the underlining usage before destruction. The destructor does cancel timer, but that does not cancel async_read_until in progress. Only when handler is called, we know the buffer ownership is back to the caller, i.e. sensor process.\n\u003e So I think shared_ptr may still be needed here.\n\nAny in progress reads are automatically canceled with an error code of operation_aborted when the boost::asio::posix::stream_descriptor is destroyed.  Given that, there\u0027s no way to have a read that\u0027s still occurring when readBuf is destroyed, because readBuf is now destroyed after inputDev.  \n\n\u003eAre we sure, even if the class(readBuf) is destructed before the handler is called\n\nGiven the patch of mine that I just merged, there is no way that readBuf can be destroyed before inputDev, and because inputDev owns the handler, there\u0027s no way the handler can be called with an invalid inputBuf given c++ destructor ordering.\n\n\u003eRe-read the docs, to me, it implies the buffer is being accessed under the hood until delimiter or error is received, then handler gets called in this process.\n\nIn this context, aborting, canceling, or destroying the object are all considered \"errors\" even if some are errors that are expected.\n\n\n\nFWIW, all of this code should be transitioned to use async_read.  The kernel guarantees that all of these descriptors will return a read in a single operation, so we should be using a fixed std::array buffer rather than a stream operator to be more efficient.",
      "parentUuid": "c533d20f_cd1a07d2",
      "range": {
        "startLine": 40,
        "startChar": 3,
        "endLine": 40,
        "endChar": 20
      },
      "revId": "8473a46fa21d720929b57cb664f89753adc772d9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "712620d6_419e5595",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-23T13:54:19Z",
      "side": 1,
      "message": "\u003e Any in progress reads are automatically canceled with an error code of \n\u003e operation_aborted when the boost::asio::posix::stream_descriptor is \n\u003e destroyed.  Given that, there\u0027s no way to have a read that\u0027s still occurring \n\u003e when readBuf is destroyed, because readBuf is now destroyed after inputDev.  \n\nThis made me realize that we are handling the ec in a different way here. When inputDev gets destroyed along with CPUSensor object, As you mentioned async_read_until return with an ec. But here we are handling ec inside a CPUSensor class method.\n\nI suppose when inputDev is destructed it return ec as operation_canceled(CPUSensor.cpp L227) and not operation_aborted. Please correct me if I am wrong.\n\nIf that is the case, we are again updating the D-Bus property at L237 in CPUSensor.cpp. By the time sdbusplus updates the property, most probably the CPUSensor object will get destroyed. Also this is the exact place coredump was pointing to as an issue.\n \n\u003e (gdb) frame 9\n\u003e #9 0x00465154 in Sensor:: markFunctional (this\u003d0xcb3168, isfunctional\u003d\u003e \u003coptimized out\u003e)\n\u003e at ../../../../../../workspace/sources/dbus-sensors/include/sensor.hpp:371\n\u003e warning: Source file is more recent than executable.\n\u003e 371\t\toperationalInterface-\u003eset_property(\"Functional\", is Functional);",
      "parentUuid": "284f1394_e82d36db",
      "range": {
        "startLine": 40,
        "startChar": 3,
        "endLine": 40,
        "endChar": 20
      },
      "revId": "8473a46fa21d720929b57cb664f89753adc772d9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}