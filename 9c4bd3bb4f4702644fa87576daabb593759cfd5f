{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f28a54fa_15c2ae4a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-05T21:57:32Z",
      "side": 1,
      "message": "Only one pretty minor naming/convention thing.  Other than that, looks good to me.",
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5e3619b4_1cbc7aa2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-06T16:35:22Z",
      "side": 1,
      "message": "Some RAII best practices, but looking pretty good.",
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc18cc44_78b58e83",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 343,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-06T16:35:22Z",
      "side": 1,
      "message": "As written, this has lifetime issues (I think).  I suspect this needs to be a std::string, so you\u0027re not relying on a pointer to the rvalue type on line 738.",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 343,
        "endChar": 21
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34f47f02_5e3d7f83",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 343,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-09T00:16:19Z",
      "side": 1,
      "message": "The only I2CDevice objects that should ever exist should be statically allocated with a string-literal name (values in a static I2CDeviceTypeMap), so I\u0027m fairly confident it should be safe as-is.  That said, if that seems too subtle or an assumption that\u0027s likely to break I can change it to allocate \u0026 copy.  (Yearning for `\u0026\u0027static str` to have that compiler-enforced...)",
      "parentUuid": "bc18cc44_78b58e83",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 343,
        "endChar": 21
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "409a4abe_3c919124",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 343,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:52:08Z",
      "side": 1,
      "message": "\u003e The only I2CDevice objects that should ever exist should be statically allocated with a string-literal name (values in a static I2CDeviceTypeMap), so I\u0027m fairly confident it should be safe as-is.\n\u003e  That said, if that seems too subtle or an assumption that\u0027s likely to break I can change it to allocate \u0026 copy.  (Yearning for `\u0026\u0027static str` to have that compiler-enforced...)\n\nI guess I kind of buy that.  I could see the argument a lot better if \nI2CDeviceTypeMap were a constexpr std::array, so there\u0027s no question there about lifetime.  In theory the main I2CDeviceTypeMap could go out of scope which would invalidate any I2CDeviceType classes in a subtle way.\n\nI\u0027m on the fence here.  Do whatever is in your best judgement.",
      "parentUuid": "34f47f02_5e3d7f83",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 343,
        "endChar": 21
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb1fcf95_ff1fd7b9",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 343,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-11T10:28:35Z",
      "side": 1,
      "message": "Given that the struct in question is a description of a device _type_ about which we require ahead-of-time knowledge (and not a device instance), I\u0027m having a somewhat hard time picturing a scenario in which we could end up instantiating a new one at runtime, so I\u0027d feel fairly comfortable leaving it as it is.  (I\u0027ll just set these words aside on a platter in case I have to eat them later...)",
      "parentUuid": "409a4abe_3c919124",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 343,
        "endChar": 21
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "750f534d_71144469",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 347,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-05T21:57:32Z",
      "side": 1,
      "message": "Not for this patchset, but in a perfect world, this would be a constexpr sorted array, so we don\u0027t take up memory all the time to host it.\n\nProblem for another patchset though.",
      "range": {
        "startLine": 347,
        "startChar": 6,
        "endLine": 347,
        "endChar": 22
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34e34aa7_d4a539d4",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 347,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-05T22:07:18Z",
      "side": 1,
      "message": "Do you mean like something that would allow it to be in the executable .rodata section instead of heap space that\u0027s initialized by pre-main() code?  If so, yeah, that\u0027d be neat, though I don\u0027t know the necessary C++ magic offhand to make it happen...",
      "parentUuid": "750f534d_71144469",
      "range": {
        "startLine": 347,
        "startChar": 6,
        "endLine": 347,
        "endChar": 22
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4089704b_200ba44d",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 347,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-06T01:37:55Z",
      "side": 1,
      "message": "\u003e Do you mean like something that would allow it to be in the executable .rodata section instead of heap space that\u0027s initialized by pre-main() code?\n\nYep\n\n\u003e  If so, yeah, that\u0027d be neat, though I don\u0027t know the necessary C++ magic offhand to make it happen...\n\nIf you want an example somewhere else we do this:\n\nhttps://github.com/openbmc/bmcweb/blob/5907571df69a5e1a6f3e0633ad42f2dc7fa6ba25/redfish-core/include/registries/openbmc_message_registry.hpp#L73\n\nThen doing a lookup on the structure:\n\nhttps://github.com/openbmc/bmcweb/blob/80f595e7c00dc5b82e1aba8828c3a8205f9a4332/redfish-core/include/event_service_manager.hpp#L99\n\nArguably we could\u0027ve used std::binary_search to make it faster, because it\u0027s sorted, but you get the idea.\n\nAgain, doesn\u0027t need to be this patch.",
      "parentUuid": "34e34aa7_d4a539d4",
      "range": {
        "startLine": 347,
        "startChar": 6,
        "endLine": 347,
        "endChar": 22
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b13bb248_756bdf89",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 347,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-09T00:16:19Z",
      "side": 1,
      "message": "Ah, I see -- I had thought you were alluding to some fancier trickery to automate the sorting at compile-time or something, but yeah, that certainly seems tractable.",
      "parentUuid": "4089704b_200ba44d",
      "range": {
        "startLine": 347,
        "startChar": 6,
        "endLine": 347,
        "endChar": 22
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2cbddfd0_ea806169",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 347,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:55:25Z",
      "side": 1,
      "message": "Nope..... Just a comment that \"Please keep this list alphabetized\" seems to do the trick.  Also, if we\u0027re that worried, a linear search on startup isn\u0027t the end of the world.",
      "parentUuid": "b13bb248_756bdf89",
      "range": {
        "startLine": 347,
        "startChar": 6,
        "endLine": 347,
        "endChar": 22
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b65a33b_2a6dc518",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 360,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-05T21:57:32Z",
      "side": 1,
      "message": "should this just be the destructor?",
      "range": {
        "startLine": 360,
        "startChar": 8,
        "endLine": 360,
        "endChar": 15
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20200263_330b5827",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 360,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-05T22:07:18Z",
      "side": 1,
      "message": "It\u0027s called explicitly from an error-handling path in the ::create() method (to handle the scenario where the new_device write succeeds but the driver initialization fails and doesn\u0027t set up the hwmon stuff), which AFAIK necessitates it remaining a regular method.",
      "parentUuid": "3b65a33b_2a6dc518",
      "range": {
        "startLine": 360,
        "startChar": 8,
        "endLine": 360,
        "endChar": 15
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47988dd9_f906288c",
        "filename": "include/Utils.hpp",
        "patchSetId": 8
      },
      "lineNbr": 360,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-06T01:37:55Z",
      "side": 1,
      "message": "I\u0027m not quite following, if create() fails, won\u0027t the object go out of scope almost immediately and get the same behavior?",
      "parentUuid": "20200263_330b5827",
      "range": {
        "startLine": 360,
        "startChar": 8,
        "endLine": 360,
        "endChar": 15
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99a7b80b_036f7ddd",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 787,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-06T16:35:22Z",
      "side": 1,
      "message": "Nit, rather than explicitly call close, please just rely on raii, and wrap line 779-786 in a scope with braces so that ctor is closed when leaving the scope.",
      "range": {
        "startLine": 787,
        "startChar": 0,
        "endLine": 787,
        "endChar": 17
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dd0854a_5d5bf92b",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 787,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-09T00:16:19Z",
      "side": 1,
      "message": "Ack, though looking back it now I think due to the buffering involved it should probably be an explicit flush followed by a `ctor.good()` test to check for write errors?",
      "parentUuid": "99a7b80b_036f7ddd",
      "range": {
        "startLine": 787,
        "startChar": 0,
        "endLine": 787,
        "endChar": 17
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6920c23_e612ebf1",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 787,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:52:08Z",
      "side": 1,
      "message": "doesn\u0027t the ifstream flush on close?  Are you seeing actual functional issues?",
      "parentUuid": "6dd0854a_5d5bf92b",
      "range": {
        "startLine": 787,
        "startChar": 0,
        "endLine": 787,
        "endChar": 17
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de30299c_874cf8c8",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 787,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-11T10:28:35Z",
      "side": 1,
      "message": "The docs I was looking at said it does (as one would certainly hope) flush on close, yes, but if we were to rely on the dtor to do that closing would we have any way of doing the .good() test after it for the error check?",
      "parentUuid": "a6920c23_e612ebf1",
      "range": {
        "startLine": 787,
        "startChar": 0,
        "endLine": 787,
        "endChar": 17
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "348e54a0_cf617ffa",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 792,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-06T16:35:22Z",
      "side": 1,
      "message": "This is what you were talking about, right?  in theory when this returns -1, the calling code is going to destroy it, and run the destructor, right?",
      "range": {
        "startLine": 792,
        "startChar": 0,
        "endLine": 792,
        "endChar": 18
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d5bf6ad_f8f219da",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 792,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-09T00:16:19Z",
      "side": 1,
      "message": "Yeah, this is the call I was referring to previously -- the lifetime of the I2CDevice object isn\u0027t really tied to the instantiation and removal of the underlying kernel hwmon device though, it\u0027s created and destroyed as part of the HwmonTempSensor object.  We might close our file descriptors and remove the device without destroying the sensor object, e.g. so that we can maintain the sensor\u0027s presence on dbus with its Available property set to false when it goes offline.\n\n...and actually, I see now it\u0027s not even just that -- at least in the current implementation (https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/56023/12), the instantiateDevices() function creates temporary local I2CDevice instances that aren\u0027t even a part of a sensor object, which would break entirely if the destructor ran and removed the hwmon device.",
      "parentUuid": "348e54a0_cf617ffa",
      "range": {
        "startLine": 792,
        "startChar": 0,
        "endLine": 792,
        "endChar": 18
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76368572_37e7ddd3",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 792,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:55:25Z",
      "side": 1,
      "message": "\u003e We might close our file descriptors and remove the device without destroying the sensor object\n\nBut..... if we want that we can still do that, right?  Just do something like\n\nstd::optional\u003cMyI2cDevice\u003e\n\nif you want to create one, use emplace, if you want to destroy one, call reset().  The advantages of this pattern are that if we throw an exception, the device gets removed appropriately.",
      "parentUuid": "6d5bf6ad_f8f219da",
      "range": {
        "startLine": 792,
        "startChar": 0,
        "endLine": 792,
        "endChar": 18
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b78dad11_a048f8b4",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 792,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-11T10:28:35Z",
      "side": 1,
      "message": "Possibly my understanding of destructors and std::optional\u003c\u003e is off, but I had thought that in a situation like:\n\n```\nfor (...)\n{\n  std::optional\u003cI2CDevice\u003e dev \u003d getI2CDevice(...);\n  ...\n}\n```\n\nthat at the end of each iteration of the loop the dtor for `dev` would be run, which would in turn run the dtor for the contained I2CDevice (if it\u0027s not nullopt), and hence close the device?  If so that would completely break `instantiateDevices()` in the later patch.\n\nI guess maybe I should clarify that as I\u0027ve implemented things thus far, the I2CDevice struct is really more just a structured representation of the device\u0027s i2c config parameters than a representation of the instantiated device itself.  It\u0027s basically just acting as a cache of the tedious work of taking a SensorBaseConfigMap (a {string:variant} dict, essentially), verifying that it has all the right keys and that they\u0027re of the right types, and then pulling the corresponding values out into an easily-accessible form.  (Possibly its name could be changed to better reflect that...)",
      "parentUuid": "76368572_37e7ddd3",
      "range": {
        "startLine": 792,
        "startChar": 0,
        "endLine": 792,
        "endChar": 18
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcd51c78_13e4c068",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 810,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-06T16:35:22Z",
      "side": 1,
      "message": "Don\u0027t need an explicit close here.  RAII will give you the same behavior without it.",
      "range": {
        "startLine": 810,
        "startChar": 0,
        "endLine": 810,
        "endChar": 17
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90a6326a_3bb98819",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 810,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-09T00:16:19Z",
      "side": 1,
      "message": "Ack, though changed to the same .flush()/.good() pattern here as well.",
      "parentUuid": "dcd51c78_13e4c068",
      "range": {
        "startLine": 810,
        "startChar": 0,
        "endLine": 810,
        "endChar": 17
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c0b14a16_3bb4e31d",
        "filename": "src/Utils.cpp",
        "patchSetId": 8
      },
      "lineNbr": 810,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:52:08Z",
      "side": 1,
      "message": "Done.  Lets follow up in the other comment.",
      "parentUuid": "90a6326a_3bb98819",
      "range": {
        "startLine": 810,
        "startChar": 0,
        "endLine": 810,
        "endChar": 17
      },
      "revId": "9c4bd3bb4f4702644fa87576daabb593759cfd5f",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}