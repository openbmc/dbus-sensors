{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "74c48729_b529300a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2022-12-27T13:58:31Z",
      "side": 1,
      "message": "FWIW, a related issue (but with adcsensor) was already discussed at https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/37345 with many good points raised. AFAICT, the conclusion is that it\u0027s essential to set the maximum to the real maximum that ADC can measure; while with adcsensors it\u0027s possible to just hardcode it for all supported devices, psusensors needs more fine-grained approach.",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4d2d9bc3_78ce7b31",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2023-01-13T10:21:21Z",
      "side": 1,
      "message": "In omnisensor the control over default min and max values is less fine-grained: https://github.com/zevweiss/omnisensor/blob/master/src/hwmon.rs#L238 . Zev, since you\u0027ve recently had a good deep dive into the topic, probably you can provide some feedback here? Is this feature (driver-specific default values) worth having at all in your opinion?",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0873d7ab_d5a5cca3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-01-13T21:19:17Z",
      "side": 1,
      "message": "I wouldn\u0027t read too much into that; I was basically just aiming for approximate feature parity with the existing psusensor code here: https://github.com/openbmc/dbus-sensors/blob/master/src/PSUSensorMain.cpp#L934-L1021\n\n(And as noted in the FIXME comment I left in that match block there I was lazy and didn\u0027t even make it fully match the existing code.)\n\nAs for whether it\u0027s worth having -- from your description there\u0027s clearly a significant shortcoming with the existing code; what I\u0027m less sure of is the right way to address it...\n\nIs the value range going to be roughly the same for all instances of that device?  If so, should we just have a fixed lookup table in the daemon to handle it automatically instead of making every instance of it specify it explicitly in its config?",
      "parentUuid": "4d2d9bc3_78ce7b31",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98625e02_ae0ab2af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2023-01-14T10:54:03Z",
      "side": 1,
      "message": "Hello Zev,\n\nThank you for chiming in.\n\n\u003e As for whether it\u0027s worth having -- from your description there\u0027s clearly a significant shortcoming with the existing code; what I\u0027m less sure of is the right way to address it...\n\nI see just two points why correct min and max values are important: precision of reporting via IPMI; automatic appropriate hysteresis. And the latter seems to be not implemented at all in omnisensor (defaults to NaN), so I\u0027d expect to see a stream of events reported when it so happens that the measured value fluctuates (e.g. in the LSB of the ADC) near a threshold unless a specific configuration for this input is added.\n\nBTW, a somewhat related idea: how about adding sanity checking for hysteresis in this manner: on startup if the first measured (and reported, since some measurements must be ignored while the host is turned off) value is within all the thresholds /but/ closer than the specified hysteresis to one of them, print a warning to the log?\n\n\u003e Is the value range going to be roughly the same for all instances of that device?  \n\nOf course, different hwmon (and other subsystem devices) can differ. E.g. a chip which measures current over a shunt resistor can have very different ranges on different boards, depending on the shunt value. But some devices (such as these pxe1610-compatible VRs, or the integrated ADC of ast2500/ast2600) have fixed limits.\n\n\u003e If so, should we just have a fixed lookup table in the daemon to handle it automatically instead of making every instance of it specify it explicitly in its config?\n\nThat\u0027s what I\u0027m proposing with this patch: to hardcode sensible values in the daemon for at least some drivers.",
      "parentUuid": "0873d7ab_d5a5cca3",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e39c04e8_f4364353",
        "filename": "src/PSUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 619,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-01-13T02:54:27Z",
      "side": 1,
      "message": "Why do we have to rely on encoding this metadata in a string? What are the alternatives and why are they worse?",
      "range": {
        "startLine": 617,
        "startChar": 0,
        "endLine": 619,
        "endChar": 80
      },
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed587a3b_f96e7716",
        "filename": "src/PSUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 619,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2023-01-13T10:11:03Z",
      "side": 1,
      "message": "Hello Andrew,\nSo basically here we need a way to match on two keys: the kernel driver name and the particular label. One way to do that would be to make labelMatch a map that uses `std::pair\u003cstd::string, std::string\u003e` for the key. That would involve changing all the existing entries in it, and adding new entries would look a bit more complex. The approach I offer is allowing to do the job with minimal changes, also similar \"metadata in a string\" idea was already accepted in c7e956275ffef . I do not consider the possibility to get a clash between such an augmented label name with another real label name to be real, so I can\u0027t see any downsides.",
      "parentUuid": "e39c04e8_f4364353",
      "range": {
        "startLine": 617,
        "startChar": 0,
        "endLine": 619,
        "endChar": 80
      },
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}