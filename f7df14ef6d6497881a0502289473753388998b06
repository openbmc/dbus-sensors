{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2a7b1782_e2302814",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 19,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-01-17T18:01:54Z",
      "side": 1,
      "message": "This is the part of this commit that I\u0027m not sure about.  The defaults are supposed to be exactly that, defaults, but I\u0027m not really sure this patchset solves the issue in a better way, given that ANY board is going to have to put in board-specific defaults.\n\nMy minor preference would be to detect and error on the cases where we get a configuration with a threshold that can\u0027t be hit, which I think solves the problem.  I\u0027m a little worried about extending the default system, because this type of hardware functionally has no good \"default\", as it depends on the board config, and any default we put in is just going to be from the first user, and still incorrect in a majority of cases, so I\u0027m not sure we gain anything overall.\n\nThe intent of the existing defaults was that we would pick the limits of what pmbus can represent, and if a system wanted to refine that, it could.  Setting per-device defaults just seems like it adds complexity in a bad way.",
      "range": {
        "startLine": 18,
        "startChar": 13,
        "endLine": 19,
        "endChar": 25
      },
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "74c48729_b529300a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2022-12-27T13:58:31Z",
      "side": 1,
      "message": "FWIW, a related issue (but with adcsensor) was already discussed at https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/37345 with many good points raised. AFAICT, the conclusion is that it\u0027s essential to set the maximum to the real maximum that ADC can measure; while with adcsensors it\u0027s possible to just hardcode it for all supported devices, psusensors needs more fine-grained approach.",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4d2d9bc3_78ce7b31",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2023-01-13T10:21:21Z",
      "side": 1,
      "message": "In omnisensor the control over default min and max values is less fine-grained: https://github.com/zevweiss/omnisensor/blob/master/src/hwmon.rs#L238 . Zev, since you\u0027ve recently had a good deep dive into the topic, probably you can provide some feedback here? Is this feature (driver-specific default values) worth having at all in your opinion?",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0873d7ab_d5a5cca3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-01-13T21:19:17Z",
      "side": 1,
      "message": "I wouldn\u0027t read too much into that; I was basically just aiming for approximate feature parity with the existing psusensor code here: https://github.com/openbmc/dbus-sensors/blob/master/src/PSUSensorMain.cpp#L934-L1021\n\n(And as noted in the FIXME comment I left in that match block there I was lazy and didn\u0027t even make it fully match the existing code.)\n\nAs for whether it\u0027s worth having -- from your description there\u0027s clearly a significant shortcoming with the existing code; what I\u0027m less sure of is the right way to address it...\n\nIs the value range going to be roughly the same for all instances of that device?  If so, should we just have a fixed lookup table in the daemon to handle it automatically instead of making every instance of it specify it explicitly in its config?",
      "parentUuid": "4d2d9bc3_78ce7b31",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98625e02_ae0ab2af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2023-01-14T10:54:03Z",
      "side": 1,
      "message": "Hello Zev,\n\nThank you for chiming in.\n\n\u003e As for whether it\u0027s worth having -- from your description there\u0027s clearly a significant shortcoming with the existing code; what I\u0027m less sure of is the right way to address it...\n\nI see just two points why correct min and max values are important: precision of reporting via IPMI; automatic appropriate hysteresis. And the latter seems to be not implemented at all in omnisensor (defaults to NaN), so I\u0027d expect to see a stream of events reported when it so happens that the measured value fluctuates (e.g. in the LSB of the ADC) near a threshold unless a specific configuration for this input is added.\n\nBTW, a somewhat related idea: how about adding sanity checking for hysteresis in this manner: on startup if the first measured (and reported, since some measurements must be ignored while the host is turned off) value is within all the thresholds /but/ closer than the specified hysteresis to one of them, print a warning to the log?\n\n\u003e Is the value range going to be roughly the same for all instances of that device?  \n\nOf course, different hwmon (and other subsystem devices) can differ. E.g. a chip which measures current over a shunt resistor can have very different ranges on different boards, depending on the shunt value. But some devices (such as these pxe1610-compatible VRs, or the integrated ADC of ast2500/ast2600) have fixed limits.\n\n\u003e If so, should we just have a fixed lookup table in the daemon to handle it automatically instead of making every instance of it specify it explicitly in its config?\n\nThat\u0027s what I\u0027m proposing with this patch: to hardcode sensible values in the daemon for at least some drivers.",
      "parentUuid": "0873d7ab_d5a5cca3",
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e39c04e8_f4364353",
        "filename": "src/PSUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 619,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-01-13T02:54:27Z",
      "side": 1,
      "message": "Why do we have to rely on encoding this metadata in a string? What are the alternatives and why are they worse?",
      "range": {
        "startLine": 617,
        "startChar": 0,
        "endLine": 619,
        "endChar": 80
      },
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed587a3b_f96e7716",
        "filename": "src/PSUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 619,
      "author": {
        "id": 1000936
      },
      "writtenOn": "2023-01-13T10:11:03Z",
      "side": 1,
      "message": "Hello Andrew,\nSo basically here we need a way to match on two keys: the kernel driver name and the particular label. One way to do that would be to make labelMatch a map that uses `std::pair\u003cstd::string, std::string\u003e` for the key. That would involve changing all the existing entries in it, and adding new entries would look a bit more complex. The approach I offer is allowing to do the job with minimal changes, also similar \"metadata in a string\" idea was already accepted in c7e956275ffef . I do not consider the possibility to get a clash between such an augmented label name with another real label name to be real, so I can\u0027t see any downsides.",
      "parentUuid": "e39c04e8_f4364353",
      "range": {
        "startLine": 617,
        "startChar": 0,
        "endLine": 619,
        "endChar": 80
      },
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aaf52712_2e678a61",
        "filename": "src/PSUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 619,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-01-17T04:30:17Z",
      "side": 1,
      "message": "As a maintainer, the downside to me is we\u0027re adding a yet another DSL to this codebase, which is already full of crazy DSLs. Honestly, I want it to stop. It\u0027s next to impossible to learn the behaviour without completely reading the code: it\u0027s an unabstraction.\n\nYou\u0027re already guarding the fallback of an un-augmented search here. The least we could do is come up with a more appropriate device-specific structure and search that first. If that fails, we fall back to the generic definitions as you\u0027ve done here. No string parsing required, and we have types that can be enforced by the compiler.",
      "parentUuid": "ed587a3b_f96e7716",
      "range": {
        "startLine": 617,
        "startChar": 0,
        "endLine": 619,
        "endChar": 80
      },
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de9a4be9_50e1c07f",
        "filename": "src/PSUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 619,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-01-17T18:01:54Z",
      "side": 1,
      "message": "+1 to andrews comment.  Build typesafe structures.\n\n\u003e That would involve changing all the existing entries in it, and adding new entries would look a bit more comple\n\nWhat you laid out would be my preference, with the exception of not using std::pair (becuase x.first and x.second have less meaning).\n\n\u003e is allowing to do the job with minimal changes\n\nPer the coding standard \"minimal changes\" is not what we optimize for.  Code will be read many... many times by developers.  It will be written once.  We optimize for the reader, and clean code, and if that means propagating a type through several layers of interfaces, that\u0027s what we do.",
      "parentUuid": "aaf52712_2e678a61",
      "range": {
        "startLine": 617,
        "startChar": 0,
        "endLine": 619,
        "endChar": 80
      },
      "revId": "f7df14ef6d6497881a0502289473753388998b06",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}