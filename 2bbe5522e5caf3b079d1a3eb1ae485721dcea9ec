{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ea9b7e5c_1e70c939",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-08-16T19:15:20Z",
      "side": 1,
      "message": "You say it\u0027s standard without putting any links to any sort of documentation on why this is a standard.  This is not a standard I\u0027ve ever heard of, I\u0027ve seen 1 generally.",
      "range": {
        "startLine": 9,
        "startChar": 54,
        "endLine": 10,
        "endChar": 33
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69e0610d_f84206ff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-08-28T16:14:29Z",
      "side": 1,
      "message": "The number 2.55 was pulled from a value that gets applied during Sensor object init if no other hysteresis value is specified. That said, I can agree with looking to avoid magic numbers here.\n\nI\u0027m currently looking at the idea of using \u0027NaN\u0027 as a default value, then having the Sensor \u0027update\u0027 function *not* overwrite existing threshold fields with NaN when encountered.",
      "parentUuid": "ea9b7e5c_1e70c939",
      "range": {
        "startLine": 9,
        "startChar": 54,
        "endLine": 10,
        "endChar": 33
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "810c9146_98a8e351",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-08-28T16:33:16Z",
      "side": 1,
      "message": "Another alternative would  be to add a hysteresis parameter to parseThresholdsFromAttr with a default value of NaN (what this fix does, but with default value NaN instead of 2.55). \n\nIn this path, instead of changing Sensor update calls to *not* overwrite Sensor thresholds with NaN, we\u0027d just leave it up to callers of parseThresholdFromAttr to specify a hysteresis value for their hardware instead of relying on values chosen during the usual Sensors init.",
      "parentUuid": "69e0610d_f84206ff",
      "range": {
        "startLine": 9,
        "startChar": 54,
        "endLine": 10,
        "endChar": 33
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50c637db_d3779b30",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-08-28T17:28:27Z",
      "side": 1,
      "message": "\u003e The number 2.55 was pulled from a value that gets applied during Sensor object init if no other hysteresis value is specified.\n\nThen say this, don\u0027t say it\u0027s a \"standard value\", just say it matches what existed before, and doesn\u0027t change behavior.\n\nMy preference would be for the later, just pass the value in with some kind of default, but I haven\u0027t looked at the sensor code in a while.",
      "parentUuid": "810c9146_98a8e351",
      "range": {
        "startLine": 9,
        "startChar": 54,
        "endLine": 10,
        "endChar": 33
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be238324_737b7ae7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-08-16T19:15:20Z",
      "side": 1,
      "message": "but doesn\u0027t this change behavior for existing systems?\n\nAs-is, there\u0027s already some hysteresis defaults specified in the Sensor implementation of 1% of sensor range.  That seems better than a hardcoded value.\n\nhttps://github.com/openbmc/dbus-sensors/blob/38857578d7243fb60f2b266d291526b5b97d0fc5/src/sensor.hpp#L72",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 14,
        "endChar": 41
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f80c5e6_efed704a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-08-28T16:14:29Z",
      "side": 1,
      "message": "As I understand it, only Intel code uses parseThresholdFromAttr at this time, and that \u00270\u0027 value hardcoded in now is a semi-recent addition in response to an Intel-specific issue @ https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/61744/\n\nI believe the issue is that (originally, before the Intel \u00270\u0027 fix)\n1) parseThresholdFromAttr didn\u0027t get a hysteresis value passed in, and in turn, didn\u0027t specify a value for Hysteresis in the vector that it created. \n\n2) the Sensor Update function (I believe only called from Intel code- by passing it a vector returned by parseThresholdFromAttr) would encounter the \u0027unspecified\u0027 field and would write \u0027NaN\u0027 as an update for the field to the Sensor, (likely) overwriting a \u00272.55\u0027 value that\u0027s applied to the hysteresis field during Sensor object init steps.\n\nAfter the Intel fix was accepted, a HW-specific hysteresis value of \u00270\u0027 will be always written when Sensor update() is called with the return from parseThresholdFromAttr().\n\nRight now, only Intel is using this pathway, so there aren\u0027t any conflicts I\u0027m aware of. This fix discussion here is aimed at removing anything HW-specific if possible, just since I happened to notice it while looking through reviews at the time.",
      "parentUuid": "be238324_737b7ae7",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 14,
        "endChar": 41
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06d7d32b_01fc6ea9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2023-08-28T17:28:27Z",
      "side": 1,
      "message": "\u003e As I understand it, only Intel code uses parseThresholdFromAttr at this time, and that \u00270\u0027 value hardcoded in now is a semi-recent addition in response to an Intel-specific issue @ https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/61744/\n\nGotcha, I wasn\u0027t aware of this background.\n\n\u003e \n\u003e I believe the issue is that (originally, before the Intel \u00270\u0027 fix)\n\u003e 1) parseThresholdFromAttr didn\u0027t get a hysteresis value passed in, and in turn, didn\u0027t specify a value for Hysteresis in the vector that it created. \n\u003e \n\u003e 2) the Sensor Update function (I believe only called from Intel code- by passing it a vector returned by parseThresholdFromAttr) would encounter the \u0027unspecified\u0027 field and would write \u0027NaN\u0027 as an update for the field to the Sensor, (likely) overwriting a \u00272.55\u0027 value that\u0027s applied to the hysteresis field during Sensor object init steps.\n\u003e \n\u003e After the Intel fix was accepted, a HW-specific hysteresis value of \u00270\u0027 will be always written when Sensor update() is called with the return from parseThresholdFromAttr().\n\u003e \n\u003e Right now, only Intel is using this pathway, so there aren\u0027t any conflicts I\u0027m aware of. This fix discussion here is aimed at removing anything HW-specific if possible, just since I happened to notice it while looking through reviews at the time.\n\nACK",
      "parentUuid": "6f80c5e6_efed704a",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 14,
        "endChar": 41
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f564a4d2_ec2f0ac2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-04-24T21:43:53Z",
      "side": 1,
      "message": "The change @ https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/62826/1 will prevent IntelCPU functionality from breaking if/when this change is accepted.",
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac0dcce3_d91fd73b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-07-21T18:24:48Z",
      "side": 1,
      "message": "The solution turns out to be a little more complex than hoped for.\n\nI got pulled in some other directions for a bit, but I\u0027m still looking into and working on solving this (likely) future-issue.",
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "659065ec_c69e040c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2023-08-02T01:12:12Z",
      "side": 1,
      "message": "Lookin forward to your update",
      "parentUuid": "ac0dcce3_d91fd73b",
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3730130_cce5f375",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-08-28T16:14:29Z",
      "side": 1,
      "message": "se",
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a60b5341_85f3c37f",
        "filename": "src/Thresholds.hpp",
        "patchSetId": 2
      },
      "lineNbr": 126,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2023-05-10T00:00:32Z",
      "side": 1,
      "message": "Specify default hysteresis that is good for all sensors is hard. options can be:\n1. use n/a, then sensor.hpp fill in the threshold based off sensors min and max\n2. derive from thresholds, for example 1% of highThreshold - lowThreshold\nIt make sense to use #1 since it is what the code does today i believe",
      "range": {
        "startLine": 126,
        "startChar": 30,
        "endLine": 126,
        "endChar": 61
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "77bf9186_2bc60fbe",
        "filename": "src/Thresholds.hpp",
        "patchSetId": 2
      },
      "lineNbr": 126,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-05-10T00:17:02Z",
      "side": 1,
      "message": "Suggestion #1 sounds like good to me. I\u0027ll take a look at sensor.hpp and see what makes sense.",
      "parentUuid": "a60b5341_85f3c37f",
      "range": {
        "startLine": 126,
        "startChar": 30,
        "endLine": 126,
        "endChar": 61
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7ad2cdfc_51ae9290",
        "filename": "src/Thresholds.hpp",
        "patchSetId": 2
      },
      "lineNbr": 126,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2023-07-21T18:24:48Z",
      "side": 1,
      "message": "After further investigation, it appears that at the time and place where \u0027parseThresholdsFromAttr()\u0027 is called from in Intel code, we don\u0027t have access to any objects with access to the high/low thresholds values to import for use here (no referenceable sensor object exists yet at this stage).\n\nIn the \u0027standard\u0027 path for handling these thresholds (ie, not going through \u0027parseThreshodlsFromAttr\u0027), a \u0027private fillMissingThresholds()\u0027 gets called after sensor instantiation to set unset threshold values (like the \u0027hysteresis\u0027 field being focused on here). \n\nI\u0027m thinking about adding a new public function to the sensor class that would do something similar to the existing \u0027set unset thresholds\u0027 , but have it only affect we\u0027re concerned about being set when \u0027parseThresholdsFromAttr\u0027 is used to define thresholds. It would be up to uses of \u0027parseThresholdsFromAttr()\u0027 to make sure to call it after the sensor object has been created (which happens after parseThresholdsFromAttr() is finished).\n\nIf that sounds alright, I\u0027ll likely submit it as an amendment to this change once I\u0027ve got some code that looks viable.",
      "parentUuid": "77bf9186_2bc60fbe",
      "range": {
        "startLine": 126,
        "startChar": 30,
        "endLine": 126,
        "endChar": 61
      },
      "revId": "2bbe5522e5caf3b079d1a3eb1ae485721dcea9ec",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}