{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ceabe80e_fda8ba80",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-21T15:39:07Z",
      "side": 1,
      "message": "Can we do this in the constructor for the class?  If the i2c bus disappears while we\u0027re running, that probably should be a fatal error.\n\n\nAlso, generally in these cases we\u0027d use std::optional to we don\u0027t have to malloc.\n\n\n\n@arj, do you recall why we\u0027re opening the i2c handle every time here?  Can\u0027t we just open it once and leave it open?",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "991cccdf_76bd924a",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-07-22T01:19:58Z",
      "side": 1,
      "message": "Because I was lazy and it was the easiest approach to reason about in terms of being the least stateful.\n\nI\u0027m fine if we refactor it.",
      "parentUuid": "ceabe80e_fda8ba80",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e93a79e_4761b153",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2022-07-22T03:33:38Z",
      "side": 1,
      "message": "Which class\u0027s constructor were you mentioning? If it\u0027s FileHandle, is that a normal thing that the user of this class should be the one catching the exception before further processing?\n\nAbout i2c handle open all the time, will it cause the bus to be busy and not be able to be used by others?",
      "parentUuid": "991cccdf_76bd924a",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53d0b1ad_bf079229",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-07-22T03:57:54Z",
      "side": 1,
      "message": "\u003e About i2c handle open all the time, will it cause the bus to be busy and not be able to be used by others?\n\nNo. You can see how open() is implemented here: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/i2c/i2c-dev.c?h\u003dv5.19-rc7\n\nIn particular, it doesn\u0027t prevent multiple-open.\n\nThe only time you\u0027re using the bus is when you issue a command to the endpoint, and any other fds open for the device will block until your command is complete. Once it completes any other commands on other fds are processed immediately by the i2c subsystem.\n\nThe behaviour is described in more depth here: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/i2c/dev-interface.rst?h\u003dv5.19-rc7",
      "parentUuid": "5e93a79e_4761b153",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8abc5a3_0a54f659",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2022-07-22T08:31:22Z",
      "side": 1,
      "message": "Yes, thanks a lot for helpful info @arj. So with the scope of the issue mentioned in this patch, a catching is an inevitable action since there is a possibility the exception will be thrown anyway. Or should I simply check if the /dev/* path exists before doing any file handling? Please gimme some advice on how I should go further with this patch.",
      "parentUuid": "53d0b1ad_bf079229",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7fcb371_3c14c6be",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-07-25T00:12:41Z",
      "side": 1,
      "message": "\u003e Which class\u0027s constructor were you mentioning? If it\u0027s FileHandle, is that a normal thing that the user of this class should be the one catching the exception before further processing?\n\nI think Ed meant in the NVMeBasicContext constructor.\n\n\u003e So with the scope of the issue mentioned in this patch, a catching is an inevitable action since there is a possibility the exception will be thrown anyway.\n\nNot if we already have a file descriptor embedded in the NVMeBasicContext instance. If you try to access a file descriptor associated with a device that\u0027s been removed you\u0027ll get something like EBADF. Please test this and confirm.\n\n\u003e Or should I simply check if the /dev/* path exists before doing any file handling?\n\nNo, that\u0027s racy. The device could disappear between the stat() and the open(), so you have to handle the open() error anyway.",
      "parentUuid": "c8abc5a3_0a54f659",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "472c1ff4_ab3fbcf0",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-07-25T03:18:44Z",
      "side": 1,
      "message": "\u003e \u003e Which class\u0027s constructor were you mentioning? If it\u0027s FileHandle, is that a normal thing that the user of this class should be the one catching the exception before further processing?\n\u003e \n\u003e I think Ed meant in the NVMeBasicContext constructor.\n\nThis is indeed what I meant.  The intent is that an i2c bus isn\u0027t going to just suddenly exists or de-exist (or if it does, there\u0027s another EM reinit that happens), so we should only throw the exception once, instead of once per loop.\n\n\u003e \n\u003e \u003e So with the scope of the issue mentioned in this patch, a catching is an inevitable action since there is a possibility the exception will be thrown anyway.\n\u003e \n\u003e Not if we already have a file descriptor embedded in the NVMeBasicContext instance. If you try to access a file descriptor associated with a device that\u0027s been removed you\u0027ll get something like EBADF. Please test this and confirm.\n\n+1\n\n\u003e \n\u003e \u003e Or should I simply check if the /dev/* path exists before doing any file handling?\n\u003e \n\u003e No, that\u0027s racy. The device could disappear between the stat() and the open(), so you have to handle the open() error anyway.\n\n\n+1",
      "parentUuid": "f7fcb371_3c14c6be",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6f6ca25_cff6abe2",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2022-07-27T08:21:24Z",
      "side": 1,
      "message": "I got your points, thank you, an i2c bus disappearing during runtime is fatal and rare. About the set of file descriptors used along the process, can I define it as a static map in NVMeBasicContext class, so that it can also be shared between the class and those global functions? I think there won\u0027t be any bus number conflict between context objects, so it needn\u0027t be separate for each NVMeBasicContext object. Or should I use rootBus to separate them in the static map? Otherwise, I\u0027m currently not able to think of another.\n\nFor the first implementation, I\u0027ll save those filehandle objects and busnumber to the map everytime we do addSensor() to the context, which is not in the NVMeBasicContext\u0027s constructor because we construct the object before having a complete set of buses. Please leave some advice. It goes something like this:\n\nIn NVMeContext class:\nvoid addSensor(const std::shared_ptr\u003cNVMeSensor\u003e\u0026 sensor)\n    {\n        sensors.emplace_back(sensor);\n        addSensorBusHandler(sensor-\u003ebus);\n    }   \n....\n\nIn NVMeBasicContext class:\n\nprivate: static std::map\u003cint, std::optional\u003cstd::shared_ptr\u003cFileHandle\u003e\u003e\u003e busHandleM;\n\nvoid NVMeBasicContext::addSensorBusHandler(int bus) //override\n{\n    //create a FileHandle object for bus and do try-catch\n    //save bus and std::optional object pointer to busHandleM viaa static setter\n}\n\n....\nIn execBasicQuery:\n{\n  //get optional object pointer fileHandle from NVMeBasicContext::busHandleM[bus] \n                                                        via a static getter\n  if (!fileHandle) \n  {resp.resize(0); return;}\n  ...\n  further process\n}",
      "parentUuid": "472c1ff4_ab3fbcf0",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9eda0fd0_80a5c6d8",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-07-28T23:15:19Z",
      "side": 1,
      "message": "There\u0027s one NVMeBasicContext per root bus, so we should only need a single file descriptor per instance. That might not be clear from the code, but I think it removes the need for any static maps.",
      "parentUuid": "c6f6ca25_cff6abe2",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e4531483_de94aa85",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2022-07-29T05:16:55Z",
      "side": 1,
      "message": "But I wonder how we can use a single fd for the rootBus to read all the channel buses behind it along the process? We are opening fd for each channel bus every loop in execBasicQuery function, so I thought we aimed to open them at the beginning instead. Please help clarify this a bit Andrew.",
      "parentUuid": "9eda0fd0_80a5c6d8",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "65873b9b_cf101688",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2022-07-30T00:27:54Z",
      "side": 1,
      "message": "\u003e But I wonder how we can use a single fd for the rootBus to read all the channel buses behind it along the process?\n\nWe can but we shouldn\u0027t, see my next comment:\n\n\u003e We are opening fd for each channel bus every loop in execBasicQuery function,\n\nYes, sorry, we seem to have sent you off on the wrong track here.\n\nThe whole basic management command thing isn\u0027t optimal to begin with. Previously nvmesensor also supported MCTP for NVMe-MI, but it was a bunch of out-of-tree patches against libmctp and the kernel and wasn\u0027t maintainable. We\u0027ve since moved MCTP into the kernel ( https://codeconstruct.com.au/docs/mctp-on-linux-introduction/ ) and added MI support to libnvme ( https://codeconstruct.com.au/docs/nvme-mi-with-libnvme/ ). With these two pieces we have a much better architecture in place to add MCTP support back to nvmesensor. Further discussion of doing so is over here:\n\nhttps://gerrit.openbmc.org/c/openbmc/docs/+/53809\n\nWe could refactor things to get rid of NVMeBasicContext entirely, and just have a list of NVMeSensors that we monitor, each with their own thread for performing the ioctl(). However, that\u0027s a bunch of work that could be better spent reintegrating MCTP support through the solutions outlined above.\n\nI feel like we add a comment along these lines and take the patch as it is now.\n\nWhat do you think about that Ed?",
      "parentUuid": "e4531483_de94aa85",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a0b0435_1adf24fa",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1001198
      },
      "writtenOn": "2022-08-04T04:03:52Z",
      "side": 1,
      "message": "It seems that we have to refactor the NVMesensor. It maybe takes more time to complete, therefore I think we can merge this patch to fix the current issue (the constructor throws an exception).\nWe should make another patch to refactor NVMesensor in the future.",
      "parentUuid": "65873b9b_cf101688",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8bbe9acc_dd960b09",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-04T17:24:12Z",
      "side": 1,
      "message": "Sure, feel free to stack as many patches as you\u0027d like in the series, but we probably can\u0027t merge the series until it results in a correct implementation.",
      "parentUuid": "5a0b0435_1adf24fa",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b95a76a_3451b5ce",
        "filename": "src/NVMeBasicContext.cpp",
        "patchSetId": 1
      },
      "lineNbr": 67,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2022-08-05T03:23:47Z",
      "side": 1,
      "message": "I don\u0027t understand much reading the proposed design and the comment section, but I got Arj\u0027s point about the idea of refactoring and I think I should leave this here as you said until I can put it somewhere along the refactoring process. Thank you.",
      "parentUuid": "8bbe9acc_dd960b09",
      "range": {
        "startLine": 67,
        "startChar": 0,
        "endLine": 67,
        "endChar": 53
      },
      "revId": "5e75815ec4a435ea34224b44ea97c2cad483d375",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}