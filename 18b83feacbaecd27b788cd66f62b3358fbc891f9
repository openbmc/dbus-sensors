{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f60f37e6_78ba4459",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-01-21T09:33:42Z",
      "side": 1,
      "message": "static?",
      "revId": "18b83feacbaecd27b788cd66f62b3358fbc891f9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd0fea92_d162f69e",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 4
      },
      "lineNbr": 42,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2022-01-21T19:57:16Z",
      "side": 1,
      "message": "The issue here is that some \"unlucky\" sensor may be starved. It does not ensure every sensor gets a chance to send the io request.\n\nHow about:\nWhen peci command fails  n consecutive times,  \n1) PECI state \u003d fail\n2) Mark sensor non-available\n3) only allow one active io request\n4) also with a slower poll rate\n5) one successful poll, go back to Normal/Success state\n\nThis should be done on per CPU, i.e. PECI bus no ideally",
      "parentUuid": "f60f37e6_78ba4459",
      "revId": "18b83feacbaecd27b788cd66f62b3358fbc891f9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c6bb385_ca68aaa0",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 4
      },
      "lineNbr": 165,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-01-21T09:33:42Z",
      "side": 1,
      "message": "Better to do -ve check here. \nif (pendingIoReqCnt \u003d 0)\n{\n  restartRead()\n  return;\n}\nThis helps to left shift below set of code.",
      "revId": "18b83feacbaecd27b788cd66f62b3358fbc891f9",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}