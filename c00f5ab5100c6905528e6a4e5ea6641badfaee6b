{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ba2afcde_96feb111",
        "filename": "src/NVMeIntf.hpp",
        "patchSetId": 21
      },
      "lineNbr": 23,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "This feels inside-out. Can we instead instantiate an object of the required type directly?",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5075e205_d341bf91",
        "filename": "src/NVMeIntf.hpp",
        "patchSetId": 21
      },
      "lineNbr": 23,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "This is more like a factory function to instantiate the different implementation but returning the common interface object. Please take a looks at some examples: \n\n1. https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/56851/22/src/NVMeSensorMain.cpp#138\n\n2. https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/57056/6/src/NVMeSensorMain.cpp#164\n\n3. https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/63048/1/tests/test_nvme_mi.cpp#16",
      "parentUuid": "ba2afcde_96feb111",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70c1c9c1_154c0a48",
        "filename": "src/NVMeIntf.hpp",
        "patchSetId": 21
      },
      "lineNbr": 23,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-11T02:43:17Z",
      "side": 1,
      "message": "Can\u0027t that be achieved by regular inheritance and dependency injection without requiring a factory function?",
      "parentUuid": "5075e205_d341bf91",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e811adc5_27817a76",
        "filename": "src/NVMeIntf.hpp",
        "patchSetId": 21
      },
      "lineNbr": 23,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-11T22:12:28Z",
      "side": 1,
      "message": "Actually I did Constructor Injection between NVMeIntf and NVMeSubsystem. \n\nWe can continue the topic [here](https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/56851/comment/d203c502_4c978003/)since they are relevant.",
      "parentUuid": "70c1c9c1_154c0a48",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44af0192_294f6c65",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 33,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "Can we instead use `filename` and `parent_path` from `std::filesystem`? Or do you feel that\u0027s slightly abusive of use of `std::filesystem`?",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "891f955c_8c663c73",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 33,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "I guess originally I didn\u0027t use the std::filesystem to avoid the ending \u0027/\u0027 or \u0027..\u0027 issue.",
      "parentUuid": "44af0192_294f6c65",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5fd21b3c_99fddbd7",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 33,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-11T02:43:17Z",
      "side": 1,
      "message": "okay. The implementation feels a bit ugly but it doesn\u0027t matter so much.",
      "parentUuid": "891f955c_8c663c73",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f9c6ee43_09c6b91c",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 36,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "Where is it specified that the object path will be of this form?",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b8625b8_79c09e3b",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 36,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "It is trying to deal with the dbus path differentiation between nvme subsystem(Drive) and sensors. \n\nThe subsystem is allocated under `/xyz/openbmc_project/inventory/system/board/$Chassis/$Drive` to model both the normal M.2/U.2 NVMe and NVMe PCIe expansion card (which has dedicated Fru EEPROM). \n\nBut all sensors are grouped under `/xyz/openbmc_project/sensors/temperature/` \n\nSo we need this \"structural\" sensor name to flatten the $Chassis/$Drive hierarchy.",
      "parentUuid": "f9c6ee43_09c6b91c",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b93afcc_242f7c32",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 36,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-11T02:43:17Z",
      "side": 1,
      "message": "Right, so something that threw me is that you\u0027ve interchanged `prod` with `chassis` in your explanation. `prod` didn\u0027t immediately have any meaning to me so it was hard to understand what the intent was. `chassis` has more obvious intent.\n\nHaving said that, what I was really looking for was a canonical link to the place where this path structure expectation is defined.",
      "parentUuid": "6b8625b8_79c09e3b",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c1b1960_f5be7ecf",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 36,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-11T22:12:28Z",
      "side": 1,
      "message": "My bad here. Typically we are using the product name for chassis so I used them interchangeable. I will update the comment\n\nAhh, I just realized gitiles still didn\u0027t render the table correctly. That is why you didn\u0027t see the dbus obj structure. \n\nhttps://github.com/openbmc/docs/blob/10f2d00fbcfb97cfb02a1ee4005d82f237783668/designs/nvmed.md#nvme-subsystem-structure\n\nGiven we have the working system right now, I can show you the output on real machines:\n\n```\n# busctl tree xyz.openbmc_project.NVMe\n`-/xyz\n  `-/xyz/openbmc_project\n    |-/xyz/openbmc_project/inventory\n    | `-/xyz/openbmc_project/inventory/system\n    |   `-/xyz/openbmc_project/inventory/system/board\n    |     `-/xyz/openbmc_project/inventory/system/board/{prod}_1\n    |       |-/xyz/openbmc_project/inventory/system/board/{prod}_1/NVMe_1\n    |       | `-/xyz/openbmc_project/inventory/system/board/{prod}_1/NVMe_1/controllers\n    |       |   `-/xyz/openbmc_project/inventory/system/board/{prod}_1/NVMe_1/controllers/0\n    `-/xyz/openbmc_project/sensors\n      `-/xyz/openbmc_project/sensors/temperature\n        |-/xyz/openbmc_project/sensors/temperature/{prod}_1_NVMe_1\n```",
      "parentUuid": "5b93afcc_242f7c32",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d2dc4cf_5a10fed5",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 92,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "This also seems like fallout from a failure to exploit inheritance?",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "88f021bc_5eaafe1c",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 92,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "The new implement is using composition. \n\nI was trying to avoid dynamic downcast with using inheritance. \n\nTake a look at the original inheritance implementation: \nhttps://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/56851/13..22/src/NVMeSubsys.cpp#b87",
      "parentUuid": "6d2dc4cf_5a10fed5",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be81aa1b_fcc8ffe9",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 92,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-11T02:43:17Z",
      "side": 1,
      "message": "I\u0027m struggling to understand what we\u0027re composing together. We\u0027re not planning to concurrently talk both protocols to the one drive instance are we?\n\nWhy would a dynamic downcast be required? We could just call a virtual method and have it dispatched to the appropriate transport implementation.",
      "parentUuid": "88f021bc_5eaafe1c",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72c840fc_7afa1990",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 92,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-11T22:12:28Z",
      "side": 1,
      "message": "\u003e I\u0027m struggling to understand what we\u0027re composing together. We\u0027re not planning to concurrently talk both protocols to the one drive instance are we?\n\nNo, one drive instance will only have one type of communication connection. \n\n\u003e Why would a dynamic downcast be required? We could just call a virtual method and have it dispatched to the appropriate transport implementation.\n\nThe the Controller will handle both protocols so it requires a downcast or de-compose at runtime to tell which protocol the node(device) supports. \n\nWe can continue the topic in https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/56851/comment/d203c502_4c978003/",
      "parentUuid": "be81aa1b_fcc8ffe9",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "17fda15c_55ef3cde",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 122,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "As above",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f319dc55_f6e80fd6",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 122,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "Replied above.",
      "parentUuid": "17fda15c_55ef3cde",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "855d3af4_9dd745e4",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 139,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "This would go away with regular inheritance.",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac3f0762_880ee78a",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 139,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "We still need it because the NVMe-MI implementation will use different dataFether/dataParser functions. \n\nhttps://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/57322/5/src/NVMeSubsys.cpp#209",
      "parentUuid": "855d3af4_9dd745e4",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8a4deba_67fdbf0e",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 139,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-11T02:43:17Z",
      "side": 1,
      "message": "In my mind that\u0027s still solved by inheritance and I\u0027m still missing the motivation. \"Using composition\" isn\u0027t a motivation in its own right. Tools for the job and all.",
      "parentUuid": "ac3f0762_880ee78a",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3b1c3ee1_01d87a01",
        "filename": "src/NVMeSubsys.cpp",
        "patchSetId": 21
      },
      "lineNbr": 139,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-11T22:12:28Z",
      "side": 1,
      "message": "Let\u0027s aggregate the topic in a single thread: \n\nhttps://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/56851/comment/d203c502_4c978003/",
      "parentUuid": "e8a4deba_67fdbf0e",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7215bb6_9b046a4c",
        "filename": "src/NVMeSubsys.hpp",
        "patchSetId": 21
      },
      "lineNbr": 36,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "encapsulated?",
      "range": {
        "startLine": 36,
        "startChar": 46,
        "endLine": 36,
        "endChar": 58
      },
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b1e9b27_dde063ab",
        "filename": "src/NVMeSubsys.hpp",
        "patchSetId": 21
      },
      "lineNbr": 36,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e7215bb6_9b046a4c",
      "range": {
        "startLine": 36,
        "startChar": 46,
        "endLine": 36,
        "endChar": 58
      },
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d203c502_4c978003",
        "filename": "src/NVMeSubsys.hpp",
        "patchSetId": 21
      },
      "lineNbr": 69,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-10T00:47:06Z",
      "side": 1,
      "message": "I don\u0027t yet appreciate the motivation for this design, but I have a nagging feeling that it\u0027s more complex than necessary. Whilst separating the concerns of fetching and parsing is reasonable, I\u0027m yet to convince myself that we need this segregated abstraction on top.\n\nFor instance, why not solve the problem with regular inheritance instead of trying to assemble all these pieces that have been stripped of coherence? Maybe my query coloured by my educational background in traditional inheritance-based approaches, but the benefit of avoiding it isn\u0027t obvious to me, and I feel exploiting it would tidy the code up.\n\nI will continue to try improve my understanding and either substantiate or dismiss that feeling.",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e26f129_7231a481",
        "filename": "src/NVMeSubsys.hpp",
        "patchSetId": 21
      },
      "lineNbr": 69,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-10T21:28:13Z",
      "side": 1,
      "message": "I think your feeling of confusion with from several design choices. Let me try to detangle it. \n\nA. Why decoupling the the NVMeIntf from NVMeSubsystem. \nThe thermal sensor is not only the dbus object we are managing now. In the current patches and future, thare are Drives, Storages, StorageControllers, Namespaces and more. We need to manage their life time according to the device status, as well as the dbus properties and methods attached to them. So my proposal is to split the functions into 3 independent classes, inspired by the MVC model. \n\nThe NVMeIntf is now a pure data provider(Model). It is completely passive w/o any life time management ability for NVMe subsystem layers nore the dbus representation. What it does is the physically layer presentation for the connection, encapsulating the message transport mangling, and scheduling for data transaction, etc. So it make you feel like you are reading from local database for these data structures with concurrency. Some examples:\n \n1. transportation handling for log pages: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/61026/3/src/NVMeMi.cpp#391; \n2. scheduling for i2c topology: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/62699/2/src/NVMeMi.cpp#25\n\nThe generated dbus server or dbus interfaces created by sdbusplus::asio is of course the View, similar to these UI classes in Android programming.\n\nThe NVMeSubsystem (and the StorageController and Namespace) classes are the Controller. It controls: \n1. The lifetime of the components. e.g. \n\n * Binding Drive and Storage life time to NVMeSubsystem: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/57034/7/include/NVMeSubsys.hpp#57\n * Binding StorageController interface to enabled NVMe controller: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/62304/2/include/NVMeController.hpp#99\n * Removing all NVMe controllers when the NSS.DF \u003d 0: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/63049/1/src/NVMeSubsys.cpp#99 \n2. When to poll the data, e.g. every 1 sec for the ctemp_poll for temperature sensor. \n3. What properties to update in the View(dbus properties). e.g. the Value of the sensor.\n\nB. Why NVMeIntf doesn\u0027t use inherence. \n\nThe Model and Controller is fully decoupled in the the design so I need a unified class for NVMeIntf passing into Controller, given I don\u0027t want the Controller to be templated. And the NVMeIntf will support both NVMe basic and NVMe-MI (w/ the real implementation and fake/mock). \n\nI have two ways to implement such common Model interface: \n\n* inherence from the common base interface. But the Controller has to downcast to each protocol using rtti. \n* composition which makes the command interface works like a union class. \n\nI turned from the first options to the second based on the discussion with Ed.",
      "parentUuid": "d203c502_4c978003",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b3a205a_7a994e32",
        "filename": "src/NVMeSubsys.hpp",
        "patchSetId": 21
      },
      "lineNbr": 69,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2023-05-11T02:43:17Z",
      "side": 1,
      "message": "\u003e The NVMeIntf is now a pure data provider(Model). It is completely passive w/o any life time management ability for NVMe subsystem layers nore the dbus representation. What it does is the physically layer presentation for the connection, encapsulating the message transport mangling, and scheduling for data transaction, etc.\n\nSo trying to put that in my own words, is it the case that `NVMeIntf` is specifically an abstraction over the mechanics of the chosen communication protocol (basic vs MCTP)?\n\n\u003e B. Why NVMeIntf doesn\u0027t use inherence. \n\u003e \n\u003e The Model and Controller is fully decoupled in the the design so I need a unified class for NVMeIntf passing into Controller, given I don\u0027t want the Controller to be templated. And the NVMeIntf will support both NVMe basic and NVMe-MI (w/ the real implementation and fake/mock).\n\nSure. You need both transports to expose a common set of behaviours, abstracting the details from the Controller. Is that a reasonable statement?\n\n\u003e \n\u003e I have two ways to implement such common Model interface: \n\u003e \n\u003e * inherence from the common base interface. But the Controller has to downcast to each protocol using rtti. \n\nIf my understanding is correct, this is the opposite of the statement above. You seem to be saying the controller requires knowledge of the implementation held by NVMeIntf, which violates the abstraction that NVMeIntf is trying to represent. In my mind, that suggests a breakdown in the design\u0027s separation of concerns.\n\n\u003e * composition which makes the command interface works like a union class. \n\nIs it possible for us to work together to get a class diagram drawn of the design? I\u0027d find it easier to comprehend at least, and maybe we could establish a shared understanding by trading diagrams. Can we try with [mermaid][] or [plantuml][]?\n\n[mermaid]: https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams\n[plantuml]: https://plantuml.com/",
      "parentUuid": "2e26f129_7231a481",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70e9c987_7020828c",
        "filename": "src/NVMeSubsys.hpp",
        "patchSetId": 21
      },
      "lineNbr": 69,
      "author": {
        "id": 1000857
      },
      "writtenOn": "2023-05-11T22:12:28Z",
      "side": 1,
      "message": "\u003e So trying to put that in my own words, is it the case that NVMeIntf is specifically an abstraction over the mechanics of the chosen communication protocol (basic vs MCTP)?\n\nYes\n\n\u003e Sure. You need both transports to expose a common set of behaviours, abstracting the details from the Controller. Is that a reasonable statement?\n\nThat is correct. The Controller(NVMeSubsystem) will determine from runtime which protocol the node is running against based on the common interface of NVMeIntf. \n\n\u003e If my understanding is correct, this is the opposite of the statement above. You seem to be saying the controller requires knowledge of the implementation held by NVMeIntf, which violates the abstraction that NVMeIntf is trying to represent. In my mind, that suggests a breakdown in the design\u0027s separation of concerns.\n\nThe Controller need the runtime information against the protocol. Saying we have a data set of A for NVMeBasic and another data set for NVMeMi. The client(Controller) will know which data set it can retrieve from Model so it can behave differently. But the interface to retrieve these two data set should be common. Thinking about SQL language or xml data binding, and in our case the NVMeIntf. \n\nThe only difference against reading data from normal datasheet is that the NVMeSubsystem is using the function name at compile time instead of the \"key\" of the column to locate the data. That is because both protocol is well defined w/ the meaning of the column (e.g. the LID of a logpage) so the programmer should know such definition b4/at the compile time. \n\n\u003e Is it possible for us to work together to get a class diagram drawn of the design? I\u0027d find it easier to comprehend at least, and maybe we could establish a shared understanding by trading diagrams. Can we try with mermaid or plantuml?\n\nSure. I posted the diagram [here](https://mermaid.ink/img/pako:eNrFVdFu2jAU_RXL2gN0hL5HCGltaBdpYUiR-rCmDxf7krokNrIdporx73MIOAkr7GXSeAB8zsk9x9f4sqNMcaQhZQUYEwnINZSEkEwS_z5_SjCWdkVuguCwuAMjWI1c4BPRJ72eTH51S7SK5omWTsQ17gHWeI1PFFtf45-i5ECfxZ8cBWm1NO_GYhmSyqD5QBXFIRHSWJBWgD1miWIyHk_PKwj5hswa59WoDn321XYNWL8ClFVJNlpZxVTRwbeghTOaTF0ti3oFDFv2M9PoEgyGn3zNDpmjXRwLDoZ9PJarptaJ2P-Z0J-bjzmZ-AzT6Qmsy91VpnWogS-c6z6SWrA91Xg8HgyJd-97N6f2d-N5HPVtZj2gFCkDeW910QdPB_QVobCvTbSFKroq4KWQj2i_qXwBOZ4Hv5D70DMfO1hW5hZcKzzwU-k16n_Suoudu2IvBb9Fwdv1tsTZ4kq6_9_f7ihqd-kdulfIX9L6x9K_KIEVZbszt94UVS5kB-CuWd-Xb88pSqP0KNJii6PUKu3CvXx4R6L4OaOzICFMyZXICYOiWIKbPfRld_ZAnexeSatdD1CTILjp76JVzaFEs3HZL4mabtARdfspQXA3vA9uGbWvWGJGQ_eVg3YxMrl3OqisSt8lo6HVFY5oteFuZBxnPQ1XUBiHIhdur8nx36D-GNENyB9KnTT73xuF1pw?type\u003dpng)\n\n[editable](https://mermaid.live/edit#pako:eNrFVdFu2jAU_RXL2gN0hL5HCGltaBdpYUiR-rCmDxf7krokNrIdporx73MIOAkr7GXSeAB8zsk9x9f4sqNMcaQhZQUYEwnINZSEkEwS_z5_SjCWdkVuguCwuAMjWI1c4BPRJ72eTH51S7SK5omWTsQ17gHWeI1PFFtf45-i5ECfxZ8cBWm1NO_GYhmSyqD5QBXFIRHSWJBWgD1miWIyHk_PKwj5hswa59WoDn321XYNWL8ClFVJNlpZxVTRwbeghTOaTF0ti3oFDFv2M9PoEgyGn3zNDpmjXRwLDoZ9PJarptaJ2P-Z0J-bjzmZ-AzT6Qmsy91VpnWogS-c6z6SWrA91Xg8HgyJd-97N6f2d-N5HPVtZj2gFCkDeW910QdPB_QVobCvTbSFKroq4KWQj2i_qXwBOZ4Hv5D70DMfO1hW5hZcKzzwU-k16n_Suoudu2IvBb9Fwdv1tsTZ4kq6_9_f7ihqd-kdulfIX9L6x9K_KIEVZbszt94UVS5kB-CuWd-Xb88pSqP0KNJii6PUKu3CvXx4R6L4OaOzICFMyZXICYOiWIKbPfRld_ZAnexeSatdD1CTILjp76JVzaFEs3HZL4mabtARdfspQXA3vA9uGbWvWGJGQ_eVg3YxMrl3OqisSt8lo6HVFY5oteFuZBxnPQ1XUBiHIhdur8nx36D-GNENyB9KnTT73xuF1pw)",
      "parentUuid": "7b3a205a_7a994e32",
      "revId": "c00f5ab5100c6905528e6a4e5ea6641badfaee6b",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}