{
  "comments": [
    {
      "key": {
        "uuid": "3acd6038_d7ddff0a",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-29T18:45:12Z",
      "side": 1,
      "message": "I see the issue;  Move the declaration of readBuf to line 38, above inputDev, and leave it as-is.\n\nThe bug here is that inputDevice can hold a reference to readBuf, so readBuf MUST be declared first, such that it\u0027s destroyed after.  Once you\u0027ve done that, the shared_ptr isn\u0027t required anymore.",
      "range": {
        "startLine": 40,
        "startChar": 4,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9201d497_6574204a",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-29T18:48:16Z",
      "side": 1,
      "message": "FWIW, it looks like ADCSensor, HwMonTempSensor, and TachSensor have this bug as well;  I suspect we should test and fix those (but it can be in another patch if you like).",
      "parentUuid": "3acd6038_d7ddff0a",
      "range": {
        "startLine": 40,
        "startChar": 4,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fd9b51c_b1bca371",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-10-29T23:47:37Z",
      "side": 1,
      "message": "\u003eThe bug here is that inputDevice can hold a reference to readBuf, so readBuf MUST be declared first, such that it\u0027s destroyed after.  Once you\u0027ve done that, the shared_ptr isn\u0027t required anymore.\nThis make sense in theory. But I don\u0027t fully understand how the bug can manifest itself in practice here. \nWill inputDev destructor access the \"dangled\" readBuf reference when CPUSensor gets destructed, which I suppose will cause service to crash? If that is the case, why it does not happen more often including all the other services?\n\nAlso, this defect is a separate defect than async_read_util handler need to ensure CPUSensor is still valid. If CPUSensor is valid the readBuf should be valid, right?",
      "parentUuid": "9201d497_6574204a",
      "range": {
        "startLine": 40,
        "startChar": 4,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45488780_80a72904",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-11-01T16:56:47Z",
      "side": 1,
      "message": "\u003e Will inputDev destructor access the \"dangled\" readBuf reference when CPUSensor gets destructed, which I suppose will cause service to crash? If that is the case, why it does not happen more often including all the other services?\n\nYes, it will access the dangled constructor.  It probably doesn\u0027t happen in the other services because the way the stack is, readBuf isn\u0027t pointing at non-program owned memory, so accessing it doesn\u0027t cause any harm, even if it is undefined behavior.\n\n\u003e \n\u003e Also, this defect is a separate defect than async_read_util handler need to ensure CPUSensor is still valid. If CPUSensor is valid the readBuf should be valid, right?\n\nCorrect.  readBuf is part of CPUSensor, so if CPU sensor hasn\u0027t been destroyed, readBuf won\u0027t be destroyed.  The issue that I see is when CPUSensor is in the process of being destroyed, readbuf will be destroyed before inputDev, with inputDev still having a pointer (reference) to readBuf, which causes an issue.",
      "parentUuid": "8fd9b51c_b1bca371",
      "range": {
        "startLine": 40,
        "startChar": 4,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "699842ee_4d41df55",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-02T12:03:16Z",
      "side": 1,
      "message": "Changing the order of declaration may solve the issue. But I myself was not able to reproduce this crash on demand. So I won\u0027t be able to confirm it. Similar issue was discussed in https://gerrit.openbmc-project.xyz/c/openbmc/dbus-sensors/+/31189/1/include/ADCSensor.hpp.\n\nBut the async_read_until says the caller should make sure the buffer is valid until the handler is getting called. https://www.boost.org/doc/libs/1_71_0/doc/html/boost_asio/reference/async_read_until/overload1.html\n\nConsidering that until the \u0027weakRef\u0027 is validated, we need the buffer to be valid. In that case I suppose we can\u0027t make use of a class variable directly.",
      "parentUuid": "45488780_80a72904",
      "range": {
        "startLine": 40,
        "startChar": 4,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c891a3a_0f8a17d6",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-11-02T18:49:12Z",
      "side": 1,
      "message": "\u003e Changing the order of declaration may solve the issue. But I myself was not able to reproduce this crash on demand. So I won\u0027t be able to confirm it. Similar issue was discussed in https://gerrit.openbmc-project.xyz/c/openbmc/dbus-sensors/+/31189/1/include/ADCSensor.hpp.\n\u003e \n\u003e But the async_read_until says the caller should make sure the buffer is valid until the handler is getting called. https://www.boost.org/doc/libs/1_71_0/doc/html/boost_asio/reference/async_read_until/overload1.html\n\nYep.  And if a read is in progress, the handler is called when the object is destroyed with operation_aborted.\n\n\u003e \n\u003e Considering that until the \u0027weakRef\u0027 is validated, we need the buffer to be valid. In that case I suppose we can\u0027t make use of a class variable directly.\n\nI\u0027m not understanding why you can\u0027t use a class variable?  Class variables are destroyed in the reverse order from which they were created.  So long as readBuf is destroyed after inputDev, we\u0027ve met the definition of what the boost docs require.",
      "parentUuid": "699842ee_4d41df55",
      "range": {
        "startLine": 40,
        "startChar": 4,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "072548ec_ba0987bd",
        "filename": "include/CPUSensor.hpp",
        "patchSetId": 2
      },
      "lineNbr": 40,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-11-03T00:16:09Z",
      "side": 1,
      "message": "My interpretation is that if CPUSensor is destroyed while async_read_until handler is already in the work queue (not because of cancel), then buffer become invalid before the handler is called.",
      "parentUuid": "8c891a3a_0f8a17d6",
      "range": {
        "startLine": 40,
        "startChar": 4,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39060017_32e89ee8",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 121,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-29T18:45:12Z",
      "side": 1,
      "message": "This is going to malloc a buffer every loop, which is pretty inefficient, and I\u0027m not sure why it\u0027s required.  Considering at CpuSensor::buffer is now covered by the weak_ptr like you\u0027ve done on the line below, isn\u0027t that all that\u0027s needed?\n\nUpdate, I see the issue, see comment above.",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 121,
        "endChar": 51
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad44865d_570d2c79",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 121,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-02T12:03:16Z",
      "side": 1,
      "message": "Please find the comments above.",
      "parentUuid": "39060017_32e89ee8",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 121,
        "endChar": 51
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ab05b00_c07e2cd7",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-29T18:45:12Z",
      "side": 1,
      "message": "Declare your variables in the scope they\u0027re used.",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 122,
        "endChar": 56
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15dacf7e_62b936fd",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-02T12:03:16Z",
      "side": 1,
      "message": "It\u0027s used at L156 as well.",
      "parentUuid": "1ab05b00_c07e2cd7",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 122,
        "endChar": 56
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2cef9ce_3b0f7240",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 138,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-29T18:45:12Z",
      "side": 1,
      "message": "Please invert this check and have it return early to reduce the number of scopes.",
      "range": {
        "startLine": 137,
        "startChar": 0,
        "endLine": 138,
        "endChar": 21
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8171a683_97426692",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 138,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-02T12:03:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b2cef9ce_3b0f7240",
      "range": {
        "startLine": 137,
        "startChar": 0,
        "endLine": 138,
        "endChar": 21
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3b24c506_730f5487",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 156,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-10-29T23:47:37Z",
      "side": 1,
      "message": "Please move this before use line 161 (same as above)",
      "range": {
        "startLine": 156,
        "startChar": 8,
        "endLine": 156,
        "endChar": 57
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "198d8509_ecdea83a",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 156,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-02T12:03:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3b24c506_730f5487",
      "range": {
        "startLine": 156,
        "startChar": 8,
        "endLine": 156,
        "endChar": 57
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "02b2c3ed_5d78aa26",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 241,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-29T18:45:12Z",
      "side": 1,
      "message": "Generally we prefer *readBuf, but in this case, I suspect readBuf doesn\u0027t need to be a shared_ptr at all.",
      "range": {
        "startLine": 241,
        "startChar": 32,
        "endLine": 241,
        "endChar": 46
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86049a20_b2cc119b",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 2
      },
      "lineNbr": 241,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-02T12:03:16Z",
      "side": 1,
      "message": "*readBuf gives below error.\n\n| ../../../../../../workspace/sources/dbus-sensors/src/CPUSensor.cpp:244:41: error: no matching function for call to \u0027std::basic_istream\u003cchar\u003e::basic_istream(std::__shared_ptr_access\u003cboost::asio::basic_streambuf\u003c\u003e, __gnu_cxx::_S_atomic, false, false\u003e::element_type\u0026)\u0027\n|   244 |     std::istream responseStream(*readBuf);",
      "parentUuid": "02b2c3ed_5d78aa26",
      "range": {
        "startLine": 241,
        "startChar": 32,
        "endLine": 241,
        "endChar": 46
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0560c55d_cfdbc1d0",
        "filename": "src/CPUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 388,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-29T18:45:12Z",
      "side": 1,
      "message": "I don\u0027t think this is needed here?  Or was there a change that necessitated this?",
      "range": {
        "startLine": 388,
        "startChar": 0,
        "endLine": 388,
        "endChar": 35
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "267f6aea_8195567e",
        "filename": "src/CPUSensorMain.cpp",
        "patchSetId": 2
      },
      "lineNbr": 388,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-11-02T12:03:16Z",
      "side": 1,
      "message": "Yes. Without this change the setupRead is not working as expected.\n\nFor setupRead() to work, it needs a shared_ptr of the CPUSensor object. If we keep the setupRead() call inside constructor, before the shared_ptr gets created, it will invoke setupRead() and it fails.",
      "parentUuid": "0560c55d_cfdbc1d0",
      "range": {
        "startLine": 388,
        "startChar": 0,
        "endLine": 388,
        "endChar": 35
      },
      "revId": "e6243e33cf78eb5801a3b0cfa6bc54fef5745960",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}