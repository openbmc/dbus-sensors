{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "eeaaf08f_67839d01",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-07T00:01:44Z",
      "side": 1,
      "message": "What do you mean by this?",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5499759_53a73964",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T19:15:40Z",
      "side": 1,
      "message": "In HPE\u0027s case, the devices in question were added to the bus from outside userspace by an HPE-specific I2C driver (i2c-gxp: https://github.com/torvalds/linux/blob/master/drivers/i2c/busses/i2c-gxp.c). \n\nSince the devices were added from outside userspace, it\u0027s my understanding that calls from inside userspace to \u0027delete_device\u0027 will fail.\n\nI\"ll think more about how to reword this line.",
      "parentUuid": "eeaaf08f_67839d01",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cef5164_6f1f1211",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-17T04:43:55Z",
      "side": 1,
      "message": "I\u0027m no sure I follow. You\u0027ve linked to the HPE GXP I2C bus driver, but I can\u0027t see that it\u0027s creating any sub-devices in its own right.",
      "parentUuid": "c5499759_53a73964",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13670852_808056da",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-18T15:24:21Z",
      "side": 1,
      "message": "Honestly, I\u0027m not too personally familiar with the specific mechanism that\u0027s working to add devices to I2C bus from outside userspace (and don\u0027t have a bound driver for host-power race condition reasons) -- but the end result is that devices like \u002750-004c\u0027 are being added to i2c bus segments from outside userspace, and as a result, the usual \"add_device\" and \"destroy_device\" writes for those devices from userspace will be \u0027blocked.\u0027 That stops the devices from getting picked up by the usual daemons.\n\nI can do a bit more digging in for the specifics on where exactly that\u0027s happening, if that detail seems important to folks--\n\nbut I\u0027d consider this to be a general \"this should work on any device added from outside userspace that had to have a driver to be bound to it by dbus daemons\" change.",
      "parentUuid": "7cef5164_6f1f1211",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fc14bf1_c22d18a2",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-07T00:01:44Z",
      "side": 1,
      "message": "How do we know that there are not other users of the driver? Why do we want to unbind drivers that we didn\u0027t instantiate? Seems like a broken lifecycle.",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b13c198_66502895",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T19:15:40Z",
      "side": 1,
      "message": "My thinking was that if we\u0027re at this point in the junction, it means we already tried to called destroy() on the object, which means we tried to do a \u0027delete_device\u0027 sysfs call -- which fails if the device in question was added to the bus from outside userspace.\n\nIn cases where a device was added to the bus from outside userspace (by a platform-specific I2C driver in HPE\u0027s case), but wasn\u0027t bound to a driver (for race condition reasons relating to host power), the dbus daemons will attempt to bind a driver (see 78011: DeviceMgmt: add driver binding support for existing devices | https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/78011 ).\n\nMy thinking was that if we\u0027re already trying to \u0027destroy\u0027 a device, it would *probably* be okay to just unbind the driver if that fails, especially since we have the ability to retry attempts to rebind that driver, especially on events like host power state changes. Restarting a d-bus daemon would also trigger a driver rebinding- if needed (but I wouldn\u0027t expect that to be necessary).\n\nThis PR calling to unbind drivers on destory()\u0027s failure to write to delete_device is related to the one linked above that binds drivers in the first place-- but I don\u0027t think this function is not vital to that one, and figured it might generate enough discussion that it\u0027d be worth having it as its own separate PR.",
      "parentUuid": "0fc14bf1_c22d18a2",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7525aa80_fee9f202",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T19:33:45Z",
      "side": 1,
      "message": "clarification: this \u0027unbind\u0027 from destroy() functionalility is *not* vital to the \u0027bind drivers to existing devices\u0027 PR linked above -- but I feel like if we\u0027re adding the ability to bind drivers, it makes sense to allow it to unbind them too, assuming no one can think of anything specific this change would break.",
      "parentUuid": "4b13c198_66502895",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "985989c6_b5dcf1c7",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T20:10:27Z",
      "side": 1,
      "message": "...maybe it\u0027d make sense to have DeviceMgmt keep track of paths for anything it successfully did a driver binding for, then only unbind on delete_device fail if it\u0027s on that list.\n\nI\u0027ll do some experimenting there -- assuming no one chimes in to say it\u0027s not needed in the meantime...",
      "parentUuid": "7525aa80_fee9f202",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}