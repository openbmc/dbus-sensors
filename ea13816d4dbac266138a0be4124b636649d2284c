{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "eeaaf08f_67839d01",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-07T00:01:44Z",
      "side": 1,
      "message": "What do you mean by this?",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5499759_53a73964",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T19:15:40Z",
      "side": 1,
      "message": "In HPE\u0027s case, the devices in question were added to the bus from outside userspace by an HPE-specific I2C driver (i2c-gxp: https://github.com/torvalds/linux/blob/master/drivers/i2c/busses/i2c-gxp.c). \n\nSince the devices were added from outside userspace, it\u0027s my understanding that calls from inside userspace to \u0027delete_device\u0027 will fail.\n\nI\"ll think more about how to reword this line.",
      "parentUuid": "eeaaf08f_67839d01",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cef5164_6f1f1211",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-17T04:43:55Z",
      "side": 1,
      "message": "I\u0027m no sure I follow. You\u0027ve linked to the HPE GXP I2C bus driver, but I can\u0027t see that it\u0027s creating any sub-devices in its own right.",
      "parentUuid": "c5499759_53a73964",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13670852_808056da",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-18T15:24:21Z",
      "side": 1,
      "message": "Honestly, I\u0027m not too personally familiar with the specific mechanism that\u0027s working to add devices to I2C bus from outside userspace (and don\u0027t have a bound driver for host-power race condition reasons) -- but the end result is that devices like \u002750-004c\u0027 are being added to i2c bus segments from outside userspace, and as a result, the usual \"add_device\" and \"destroy_device\" writes for those devices from userspace will be \u0027blocked.\u0027 That stops the devices from getting picked up by the usual daemons.\n\nI can do a bit more digging in for the specifics on where exactly that\u0027s happening, if that detail seems important to folks--\n\nbut I\u0027d consider this to be a general \"this should work on any device added from outside userspace that had to have a driver to be bound to it by dbus daemons\" change.",
      "parentUuid": "7cef5164_6f1f1211",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab7917ac_cb386604",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-19T01:53:30Z",
      "side": 1,
      "message": "Well, I think it\u0027s important that we understand what the lifecycles at hand actually are if we\u0027re going to try fixing it?\n\nAre the devices described in your devicetree?",
      "parentUuid": "13670852_808056da",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3a84912_94145d7e",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-19T16:29:39Z",
      "side": 1,
      "message": "The I2C bus segments are described in the DTS, but the individual sensors nodes that are discovered during the I2C-GXP probing process are not.\n\nMy current understanding of the life cycle is that HPE has published I2C-GXP drivers that scan each bus, detects sensor devices that may still be powered off, and adds the devices to the appropriate I2C bus, visible in sysfs. \n\nIt\u0027s my understanding that any device added to an I2C bus from outside userspace will not be able to make use of destroy_device or add_device (since a device already exists at the spot, and can\u0027t be removed from usespace) -- which is the main issue that stopped daemons like HwmonTempSensor from picking up sensors on HPE platforms.\n\nThis limitation would apply to any platform that has any devices added to an I2C bus from outside userpsace.\n\nI can do a bit more digging to work out \"where specifically does the device get added to a bus in GXP-I2C code\" element. I believe I had it figured in the past, but it\u0027s been long enough since I poked around in that code that I\u0027ll need to get a refresher.\n\nSidenote: I\u0027m currently looking at putting together some code that would keep track of whether or not the daemon needed to bind a driver, which would determine whether or not it tries to unbind them when destroy() is called.",
      "parentUuid": "ab7917ac_cb386604",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74046e15_66803d6b",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-19T17:17:17Z",
      "side": 1,
      "message": "\u003edetects sensor devices that may still be powered off, and adds the devices to the appropriate I2C bus, visible in sysfs.\n\nI asked someone with a deeper understanding of the existing HPE I2C stack, and am told it\u0027s not directly the GXP-I2C driver that\u0027s adding sensors after all.\n\n\u003eThe HPE GXP I2C driver provides the interface for the core I2C subsystem to interact with our I2C engine. The core i2c subsystem in collaboration with the device tree discovers devices listed there and will enable the probe of said devices when the I2c address is discovered.\n\nMy updated understanding is that device nodes visible in sysfs like \u002750-004c\u0027 are being added by a temp-sensor specific driver HPE has out that works on top of the structures enabled through the GXP-I2C driver. \n\nI\u0027ll keep digging in for more specifics here, but I don\u0027t expect the specifics to change the end result (add_device calls DBus Daemons rely on will fail and the sensor will be skipped), or the fix for it happening.",
      "parentUuid": "b3a84912_94145d7e",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3bc3322_585b4bbf",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-19T22:46:09Z",
      "side": 1,
      "message": "\u003e Sidenote: I\u0027m currently looking at putting together some code that would keep track of whether or not the daemon needed to bind a driver, which would determine whether or not it tries to unbind them when destroy() is called.\n\nSounds good.",
      "parentUuid": "74046e15_66803d6b",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "befbe2be_9bc4587c",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 200,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-26T22:40:57Z",
      "side": 1,
      "message": "The newest update now tracks sysfs paths for devices it binds drivers for.\n\nI\u0027ve confirmed that \u0027destroy\u0027 works with the new checks, and successfully removes the appropriate path from the list of tracked devices when it\u0027s called.\n\nDestroy gets called if HwmonTempsensor does a write to \u0027probe\u0027 but the drive probe fails to create a hwmon node -- not uncommon, and is even expected -- happens early in boot due to host power race conditions.",
      "parentUuid": "e3bc3322_585b4bbf",
      "range": {
        "startLine": 199,
        "startChar": 50,
        "endLine": 200,
        "endChar": 34
      },
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fc14bf1_c22d18a2",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-02-07T00:01:44Z",
      "side": 1,
      "message": "How do we know that there are not other users of the driver? Why do we want to unbind drivers that we didn\u0027t instantiate? Seems like a broken lifecycle.",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b13c198_66502895",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T19:15:40Z",
      "side": 1,
      "message": "My thinking was that if we\u0027re at this point in the junction, it means we already tried to called destroy() on the object, which means we tried to do a \u0027delete_device\u0027 sysfs call -- which fails if the device in question was added to the bus from outside userspace.\n\nIn cases where a device was added to the bus from outside userspace (by a platform-specific I2C driver in HPE\u0027s case), but wasn\u0027t bound to a driver (for race condition reasons relating to host power), the dbus daemons will attempt to bind a driver (see 78011: DeviceMgmt: add driver binding support for existing devices | https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/78011 ).\n\nMy thinking was that if we\u0027re already trying to \u0027destroy\u0027 a device, it would *probably* be okay to just unbind the driver if that fails, especially since we have the ability to retry attempts to rebind that driver, especially on events like host power state changes. Restarting a d-bus daemon would also trigger a driver rebinding- if needed (but I wouldn\u0027t expect that to be necessary).\n\nThis PR calling to unbind drivers on destory()\u0027s failure to write to delete_device is related to the one linked above that binds drivers in the first place-- but I don\u0027t think this function is not vital to that one, and figured it might generate enough discussion that it\u0027d be worth having it as its own separate PR.",
      "parentUuid": "0fc14bf1_c22d18a2",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7525aa80_fee9f202",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T19:33:45Z",
      "side": 1,
      "message": "clarification: this \u0027unbind\u0027 from destroy() functionalility is *not* vital to the \u0027bind drivers to existing devices\u0027 PR linked above -- but I feel like if we\u0027re adding the ability to bind drivers, it makes sense to allow it to unbind them too, assuming no one can think of anything specific this change would break.",
      "parentUuid": "4b13c198_66502895",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "985989c6_b5dcf1c7",
        "filename": "src/DeviceMgmt.cpp",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2025-02-10T20:10:27Z",
      "side": 1,
      "message": "...maybe it\u0027d make sense to have DeviceMgmt keep track of paths for anything it successfully did a driver binding for, then only unbind on delete_device fail if it\u0027s on that list.\n\nI\u0027ll do some experimenting there -- assuming no one chimes in to say it\u0027s not needed in the meantime...",
      "parentUuid": "7525aa80_fee9f202",
      "revId": "ea13816d4dbac266138a0be4124b636649d2284c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}