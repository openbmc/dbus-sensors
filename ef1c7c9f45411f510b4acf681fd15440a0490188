{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bfdaf049_03e84072",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-07-15T14:20:00Z",
      "side": 1,
      "message": "I\u0027m not sure I understand this patch, but other people have looked into it in more depth than I have.",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d01cf14_345aa225",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2025-08-01T01:42:05Z",
      "side": 1,
      "message": "Can you please review https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/82199 ?",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "88f13fde_ed48f821",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2025-08-19T11:07:11Z",
      "side": 1,
      "message": "I believe the approach in [Gerrit 82199] can also resolve the issue that my commit aims to address, since it will re-check the hardware PWM value regardless.\nHowever, this method introduces additional reads of the hardware PWM value and does not use the dbus value as a cache.\nI\u0027m not sure whether this behavior would be acceptable.\n\n[Gerrit 82199]: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/82199",
      "parentUuid": "1d01cf14_345aa225",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b8b3c51b_46a071a0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2025-09-06T06:35:31Z",
      "side": 1,
      "message": "While there are still some unresolved design issues, this is still better than the existing status quo, so I am voting to approve.",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d939c37b_b4fb5c94",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-09-08T07:16:44Z",
      "side": 1,
      "message": "LGTM.",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "361aa98d_7d8b66ba",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 96,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2025-07-17T18:33:17Z",
      "side": 1,
      "message": "This brought up another question. The purpose of `Target` versus `Value` is subtle. I think, but am not entirely sure, that there were 3 reasons:\n* `Target` is integer, from 0 to 255, so it easily maintains a 1:1 correspondence to the underlying Linux kernel `hwmon` interface (for fan PWM).\n* Being an integer, it can always be easily compared for equality without floating-point loss, which is important for the optimization of avoiding duplicate settings if the setting already matches what was desired.\n* `Target` is always read/write, versus `Value` which was always read-only until late 2021 when the `ValueMutability` feature landed.\n\nOther than these, the `Target` value is interchangeable with `Value`, IIRC. They update each other, in lockstep. Changing one, always and instantly, will change the other. At least that\u0027s how it\u0027s been, in my experience, for fan PWM.\n\nTo change the meaning of `Target` or `Value` now, to have it reflect the delayed response from the hardware instead of the user\u0027s instantaneous desired intent, might have other side effects. We might need a third field. However, this would require an interface change. The advantage of adding a third field is that it would help disambiguate all of this historical baggage, and it would help greatly for user-settable sensors, to avoid the race condition between the desired setting (flowing down from user to hardware), and the actual value (flowing up from hardware to user).",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f12d1370_28d562fb",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 96,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2025-08-21T06:40:52Z",
      "side": 1,
      "message": "Would it make sense to try the following approach:\nKeep `Target` and `Value` interchangeable as before, and add a new read/write D-Bus property that explicitly stores `user intent`.\n\nThis property would serve as the canonical reference for write decisions (i.e., when a PWM write is requested via any property, the incoming value is compared against the last recorded `user intent` to decide whether to write to hardware).\n\nThis way, any of the three properties could trigger a PWM write, but the write-decision logic would always compare the incoming value against the last recorded `user intent`, rather than against the current `Value` or `Target`.\n\nSeparately, I noticed [Gerrit 82199] takes a more direct approach to fix this issue, but it introduces additional reads of the hardware PWM file and does not rely on the D-Bus property to decide whether to write to hardware.\n\nI’d appreciate additional feedback from reviewers on which direction is preferred.\n\n[Gerrit 82199]: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/82199",
      "parentUuid": "361aa98d_7d8b66ba",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e44e551_b490a9d3",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-15T13:37:14Z",
      "side": 1,
      "message": "So in case of `- Delayed Reflection Drivers (e.g., max31790)`\nwe can set `Value` property (which is meaningless, since we do not control the currently driven PWM) and it then goes ahead to set `Target` property.\n\n@eric.yang.wiwynn@gmail.com\nWhy would a caller not directly set `Target` property?\n\nThe `Sensor.Value` interface is documented to be read-only.\n\n\u003e All Sensor.Value properties are read-only.\n\nhttps://github.com/openbmc/phosphor-dbus-interfaces/blob/master/yaml/xyz/openbmc_project/Sensor/Value.interface.yaml",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75c6b038_3d787791",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2025-07-17T06:46:22Z",
      "side": 1,
      "message": "I originally thought that users could control the PWM simply by setting the `Target` property.\nHowever, [discussions in the comments of Patchset 4] suggested that we should retain the original functionality of setting the PWM via the `Value` property as well.\nAdditionally, I\u0027m not sure whether other parts of the OpenBMC codebase set the PWM through the `Value` property.\nMoreover, I need `Target` to reflect the user’s intended PWM value in order to address the issue this patch is meant to solve.\nThat’s why I implemented this by calling the set `Target` property method here.\n\nRegardless of whether setting the `Value` property also sets the PWM, this does not affect resolving issues such as the `Delayed Reflection Drivers` problem, as long as the `Target` property always reflects the user\u0027s intent and does not change according to the actual PWM file value from the driver.\n\n[discussions in the comments of Patchset 4]: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/79824/comment/51cb8408_c5930df4/",
      "parentUuid": "0e44e551_b490a9d3",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2996994_8ec2e2f0",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-17T08:55:52Z",
      "side": 1,
      "message": "\u003e suggested that we should retain the original functionality of setting the PWM via the Value property as well.\n\nThe `Sensor.Value` interface is documented to be read-only and it has been that way ever since the interface was first documented in the PDI in 2016.\n\nIt\u0027s a Sensor, reading a value. There is no sense in writing to it. Conceptually it does not make any sense (at least not to me).\n\n@patrick@stwcx.xyz Should we update the yaml on `Sensor.Value` to clarify that it is also meant as a writable control interface in some cases?\n\nOtherwise we could probably add a big \n```lg2::error(\"Writing to a read-only sensor interface\")```\nstatement into the setter there and leave it there for a while to see if anything actually uses the interface in that way.",
      "parentUuid": "75c6b038_3d787791",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34a650b8_180efe35",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2025-07-17T17:55:33Z",
      "side": 1,
      "message": "Careful, because since we updated it in 2021, the `Sensor.Value` field can also be read/write, if it is mutable. See the `ValueMutability` interface here: https://gerrit.openbmc.org/c/openbmc/phosphor-dbus-interfaces/+/36333\n\nThe implementation is in https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/45405 and a user of this feature, the IPMI server, is here: https://gerrit.openbmc.org/c/openbmc/phosphor-host-ipmid/+/45407",
      "parentUuid": "a2996994_8ec2e2f0",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ec0e0bf_777bdfd9",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2025-07-17T18:06:01Z",
      "side": 1,
      "message": "Here\u0027s where the IPMI sensor performs the write: https://github.com/openbmc/phosphor-host-ipmid/blob/master/dbus-sdr/sensorcommands.cpp#L831-L833\n\nI wonder if we should update the YAML documentation for `Sensor.Value` to show that it is read/write in some situations, but read-only in most situations? Not sure how to indicate that the permissions are contingent on something else (in this case the `ValueMutability.Mutable` setting).",
      "parentUuid": "34a650b8_180efe35",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9dc94a4c_1ba49011",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-18T08:29:42Z",
      "side": 1,
      "message": "\u003e I wonder if we should update the YAML documentation for Sensor.Value to show that it is read/write in some situations, but read-only in most situations?\n\nRaised https://gerrit.openbmc.org/c/openbmc/phosphor-dbus-interfaces/+/82110,\nplease review.\n\n\u003e Not sure how to indicate that the permissions are contingent on something else (in this case the ValueMutability.Mutable setting).\n\nI don\u0027t think that\u0027s something the yaml or the generated code currently supports.\n\n\u003e and a user of this feature, the IPMI server, is here\n\ngood to know at least someone here has an overview 😊",
      "parentUuid": "0ec0e0bf_777bdfd9",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c6e12d2_9ed9e59d",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1000520
      },
      "writtenOn": "2025-07-18T23:44:32Z",
      "side": 1,
      "message": "Thanks! Reviewed it.\n\nFYI, I also tried to find the equivalent sensor write handler in the Redfish server, `bmcweb`, but did not find it after a quick look. I\u0027m pretty sure this feature exists already, it might have been in a local patch? Regardless, the `ValueMutability` interface is intended for any situation in which there\u0027s a sensor write request coming in from an external source and we need to validate if it\u0027s allowed or not.\n\nThe important thing here is that `Value` can be written to, just like `Target`, and there\u0027s really no prohibition on the user doing so, if they have permission, so we have to handle these equivalently. I wonder if we should add additional fields, perhaps `IntendedValue` and/or `HardwareValue`, to disambiguate?",
      "parentUuid": "9dc94a4c_1ba49011",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a502e90f_4684551b",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-21T08:05:06Z",
      "side": 1,
      "message": "Maybe i am not getting the big picture here, but do we actually need a Pwm `Sensor`?\n\nThe PID loop is taking temperatures and adjusting the pwm value to control the fan speed.\n\nIf the fan speed is not reaching the requested value after some time then that\u0027s an error condition.\n\nSince the pwm is a control input which is assumed to just \u0027work\u0027 if correctly configured. So we should be able to assume it always has the correct value?\n\nLooked into the `max31790` datasheet and there they mention the delay to reflection can be up to `125ms` which i would consider to be a minor delay and probably nothing to worry about in the control loop.\n\nSince the PwmSensor looks like the interface boundary between the sysfs and the PID loop, can we just shortcut the implementation to store the pwm value internally anytime the user sets it and return that if requested?\n\nIf there is anything bypassing the PwmSensor, that\u0027s broken anyways?\n\nAnother point: concepts like \u0027Threshold\u0027 do not make sense for a control input.",
      "parentUuid": "3c6e12d2_9ed9e59d",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9939391a_f2ada59e",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1002134
      },
      "writtenOn": "2025-08-19T11:07:11Z",
      "side": 1,
      "message": "Would it be preferable to avoid making the `Target` property reflect pure “user intent,” and instead keep the user intent as an internal variable used to decide whether to write to the hardware?\nThis would keep the external properties aligned with the actual hardware PWM value while still preserving intent internally for comparison.\n\nSeparately, I reviewed [Gerrit 82199].\nIt addresses inconsistencies by re-reading the hardware PWM in the setters and updating only when the hardware differs.\nThat should also solve this issue, but it does increase reads of the hardware PWM file.\n\n@patrick@stwcx.xyz, could you kindly share your thoughts or preference?\n\n[Gerrit 82199]: https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/82199",
      "parentUuid": "a502e90f_4684551b",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd7ae0e8_98318d7e",
        "filename": "src/PwmSensor.cpp",
        "patchSetId": 14
      },
      "lineNbr": 97,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-09-08T07:16:44Z",
      "side": 1,
      "message": "I prefer this over [Gerrit 82199](https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/82199).\n\nWhen it comes to phosphor-fan-presence repo, phosphor-fan-monitor service compares between `Target` and `Value` for a configured period of time to see if `Value` lies within the allowed range computed from `Target` and a set of offset, deviation, ... This is to ensure that the physical fans are running at the desired speed set to `Target` by phosphor-fan-control service. If this check fails, `Functional` property is set to false for fan inventory objects under phosphor-inventory-manager \u003d\u003e fan fault LED might be turned ON.\n\nIf both `Value` and `Target` show hardware value, this check will never fail. So separate implementations of the two can better adhere to their names and help in those monitoring practices.\n\nTo double check, if I intentionally set 255 to a fan that was previously controlled to be running at 150, `Value` will show the new speed and `Target` will still show 150/255, right?",
      "parentUuid": "9939391a_f2ada59e",
      "revId": "ef1c7c9f45411f510b4acf681fd15440a0490188",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}