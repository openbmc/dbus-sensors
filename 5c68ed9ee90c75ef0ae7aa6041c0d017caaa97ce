{
  "comments": [
    {
      "key": {
        "uuid": "d0aea54e_ebbc0ac5",
        "filename": "include/sensor.hpp",
        "patchSetId": 6
      },
      "lineNbr": 105,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-27T17:20:05Z",
      "side": 1,
      "message": "Sensor values are expected to be set on the order of once a second in some scenarios.  We can\u0027t be invoking a dbus method call for every set.\n\n\nAlso, you\u0027ve now made the match unused, without actually removing it, although i think it\u0027s still required.",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 105,
        "endChar": 34
      },
      "revId": "5c68ed9ee90c75ef0ae7aa6041c0d017caaa97ce",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0a7774e_c0042ac8",
        "filename": "include/sensor.hpp",
        "patchSetId": 6
      },
      "lineNbr": 105,
      "author": {
        "id": 1001049
      },
      "writtenOn": "2021-10-28T07:52:55Z",
      "side": 1,
      "message": "@Ed, the code before this used to read /xyz/openbmc_project/security/special_mode once during boot up of dbus-sensors and store the value in a member variable (getManufactMode). The disadvantage of that approach is that if dbus-sensors boots up before /xyz/openbmc_project/security/special_mode interface is up, then the dbus call will fail and the member variable getManufactMode will always stay false. Which means user will never be able to set a value. \n\nWe can solve this in two ways\n1) Make sure dbus-senors boots up only after /xyz/openbmc_project/security/special_mode interface is up.\n2) Read /xyz/openbmc_project/security/special_mode interface every time we are trying to set a value. \n\nSnehalatha has implemented the 2nd method. \n\n@Snehalatha, I would suggest to stop the dbus call after the first successful read of the interface /xyz/openbmc_project/security/special_mode. \nThat is, if interface /xyz/openbmc_project/security/special_mode is not up \u0027if (ec){return;}\u0027 will be called. But once the interface is up and we are successfully able to read the manufacturing mode, stop the dbus calls. And just use getManufactMode from thereafter. \n\nAs manufacturing mode cannot change in runtime.",
      "parentUuid": "d0aea54e_ebbc0ac5",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 105,
        "endChar": 34
      },
      "revId": "5c68ed9ee90c75ef0ae7aa6041c0d017caaa97ce",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d4a4a0d_9bb7aa1b",
        "filename": "include/sensor.hpp",
        "patchSetId": 6
      },
      "lineNbr": 105,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2021-10-28T08:35:04Z",
      "side": 1,
      "message": "I agree with Ed here. Adding a D-Bus call on every sensor value update will be an overhead.\n\nFrom @Arunlal\u0027s comment i understand the issue is because we are not getting the latest updated value for mfg mode since the specialModeManager starts late. To solve the same we can use a variable in sensor.hpp to cache the mfg mode and register for interface added signal with specialModeManager. So even after the initial D-Bus call to read the property failed, later once the service is up we get the interface added signal and we can read and cache the correct value.\n\nI suppose we are already monitoring for propertyChanged signal to listen for any further change in value.",
      "parentUuid": "a0a7774e_c0042ac8",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 105,
        "endChar": 34
      },
      "revId": "5c68ed9ee90c75ef0ae7aa6041c0d017caaa97ce",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c9471db_c53c51c1",
        "filename": "include/sensor.hpp",
        "patchSetId": 6
      },
      "lineNbr": 105,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-10-28T16:16:34Z",
      "side": 1,
      "message": "\u003e @Ed, the code before this used to read /xyz/openbmc_project/security/special_mode once during boot up of dbus-sensors and store the value in a member variable (getManufactMode). The disadvantage of that approach is that if dbus-sensors boots up before /xyz/openbmc_project/security/special_mode interface is up, then the dbus call will fail and the member variable getManufactMode will always stay false. Which means user will never be able to set a value. \n\u003e We can solve this in two ways\n1) Make sure dbus-senors boots up only after /xyz/openbmc_project/security/special_mode interface is up.\n2) Read /xyz/openbmc_project/security/special_mode interface every time we are trying to set a value. \n\nYou\u0027ve forgotten option 3, which is read the property on startup AND set up a match to see if the property ever changes, which solves the startup race condition.  We use this same pattern all over the place to great effect.\n\n\u003e As manufacturing mode cannot change in runtime.\n\nI would prefer to not rely on that assumption.  There are likely scenarios where it can change at runtime.",
      "parentUuid": "8d4a4a0d_9bb7aa1b",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 105,
        "endChar": 34
      },
      "revId": "5c68ed9ee90c75ef0ae7aa6041c0d017caaa97ce",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc4788c6_1cd0e0d9",
        "filename": "include/sensor.hpp",
        "patchSetId": 6
      },
      "lineNbr": 105,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2021-10-29T20:52:10Z",
      "side": 1,
      "message": "\u003e \u003e As manufacturing mode cannot change in runtime.\n\u003e \n\u003e I would prefer to not rely on that assumption.  There are likely scenarios where it can change at runtime.\n\nIntel platforms automatically exit manufacturing mode after 15 minutes if no timer reset command is sent. So yes, we need to continue to monitor it.",
      "parentUuid": "9c9471db_c53c51c1",
      "range": {
        "startLine": 104,
        "startChar": 0,
        "endLine": 105,
        "endChar": 34
      },
      "revId": "5c68ed9ee90c75ef0ae7aa6041c0d017caaa97ce",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}