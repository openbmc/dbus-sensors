{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e9cc7871_57bdf556",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-04T18:40:48Z",
      "side": 1,
      "message": "Can you elaborate on what these reasons would be?  EAGAIN generally means that the descriptor needs read again because it was interrupted, which is exactly what asio does.",
      "range": {
        "startLine": 9,
        "startChar": 3,
        "endLine": 9,
        "endChar": 18
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d47e9830_850845de",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2022-01-06T01:18:29Z",
      "side": 1,
      "message": "asio\u0027s async_read_until does not handle EAGAIN reliably. Same issue was identified and fix for PSUSensor here: https://github.com/openbmc/dbus-sensors/commit/bcf76717697238e380be785bd28150963ecf0e9e",
      "parentUuid": "e9cc7871_57bdf556",
      "range": {
        "startLine": 9,
        "startChar": 3,
        "endLine": 9,
        "endChar": 18
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6bdff72c_71933495",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-04T18:40:48Z",
      "side": 1,
      "message": "Why would the driver use this error code if it didn\u0027t intend to be immediately re-read?  This seems like the wrong error code.",
      "range": {
        "startLine": 10,
        "startChar": 4,
        "endLine": 10,
        "endChar": 36
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30ccea47_6215359b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-04T18:40:48Z",
      "side": 1,
      "message": "50/72 wrapping please.",
      "range": {
        "startLine": 10,
        "startChar": 38,
        "endLine": 10,
        "endChar": 74
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5f0b2fb_a00dce77",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2022-01-06T01:18:29Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "30ccea47_6215359b",
      "range": {
        "startLine": 10,
        "startChar": 38,
        "endLine": 10,
        "endChar": 74
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f4ff0f65_3cef55f4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 10,
      "author": {
        "id": 1001049
      },
      "writtenOn": "2022-01-20T13:54:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a5f0b2fb_a00dce77",
      "range": {
        "startLine": 10,
        "startChar": 38,
        "endLine": 10,
        "endChar": 74
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "56184345_6300e030",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2022-01-06T01:18:29Z",
      "side": 1,
      "message": "me",
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69127341_0cfe8308",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2022-01-06T01:19:30Z",
      "side": 1,
      "message": "Not sure how this git published. oops",
      "parentUuid": "56184345_6300e030",
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3113ea97_64823848",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 252,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2022-01-06T01:24:27Z",
      "side": 1,
      "message": "need to check fd\u003e\u003d0",
      "range": {
        "startLine": 252,
        "startChar": 14,
        "endLine": 252,
        "endChar": 16
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9c5e264_9d3a7728",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 252,
      "author": {
        "id": 1001049
      },
      "writtenOn": "2022-01-20T13:54:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3113ea97_64823848",
      "range": {
        "startLine": 252,
        "startChar": 14,
        "endLine": 252,
        "endChar": 16
      },
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "911c1a8a_faefb3c2",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 317,
      "author": {
        "id": 1000479
      },
      "writtenOn": "2022-01-20T14:05:03Z",
      "side": 1,
      "message": "We might need to increase the sensor pollTime in this error case as well.",
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ef84cc8_ccb1814f",
        "filename": "src/CPUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 317,
      "author": {
        "id": 1001049
      },
      "writtenOn": "2022-01-20T14:20:27Z",
      "side": 1,
      "message": "100 sensor objects means 70 sec (100 * 0.7 sec, go through commit message for more derails) between consecutive read of same sensor object. So poll time will have to be 70 sec. Assuming all sensors are facing peci error. \n\nNow if sensor objects are 50, it will be 35 sec. So we cannot fix a sensorFailedPollTimeMs. \n\nWith pendingIoReqCnt, we can handle this in a better way. Line 165 we check if io is free to read, else we async wait again, so in my above example we will call restartRead 14 times (sensorFailedPollTimeMs \u003d 5 sec, 70/5 \u003d 14) before making inputDev.async_wait at line 178. Effectively giving us the appropriate wait time in every situation.",
      "parentUuid": "911c1a8a_faefb3c2",
      "revId": "0d0339bf091041d3604fe7fe5f095c772e487f8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}