{
  "comments": [
    {
      "key": {
        "uuid": "18e342d4_b747d4f8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "Please don\u0027t wrap your lines by hand.  Lines should be wrapped 50/72 please.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 9,
        "endChar": 51
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd00b1f4_205d3519",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-19T21:56:42Z",
      "side": 1,
      "message": "Is the read until eventually going to finish or is it hung? \nWhat is the root cause for this? Is device busy, driver issue or other reason?\nHow to recover from this, close and reopen the file or simply cancel and retry?",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2963ed90_7ab565fb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "\u003e Is the read until eventually going to finish or is it hung? \n\u003e What is the root cause for this? Is device busy, driver issue or other reason?\n\n+1 this implies that a driver is hung.  I\u0027m not against protections in this area, but we need a proper root cause on what\u0027s happening.\n\n\u003e How to recover from this, close and reopen the file or simply cancel and retry?\n\nI suspect that\u0027s going to depend on what the real root cause is.",
      "parentUuid": "bd00b1f4_205d3519",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "814607f6_9b6a5ec6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-22T02:04:54Z",
      "side": 1,
      "message": "Take \"power1_input\" for example, hwmon drive still working well to update \"/sys/class/hwmon/hwmon2/power1_input\" but \"async_read_until\" cannot return to callback function.",
      "parentUuid": "2963ed90_7ab565fb",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20b49ff9_192e06d7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-22T18:59:14Z",
      "side": 1,
      "message": "The question is why (and what cause) \"async_read_until\" can\u0027t return?",
      "parentUuid": "814607f6_9b6a5ec6",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2fb937f2_9d7e99bb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-23T02:32:04Z",
      "side": 1,
      "message": "I don\u0027t know.\nThe correct way, async_read_until will callback when read char \u0027\\n\u0027 (0x0a).\nAt error case, async_read_until cannot callback, but the value still changed in the device file like \"/sys/class/hwmon/hwmon2/power1_input\" and char \u0027\\n\u0027 (0x0a) is there.\n\nroot@intel-obmc:/lib/systemd/system# hexdump /sys/class/hwmon/hwmon2/power1_input \n0000000 3033 3538 3030 3030 0a30               \n000000a\n\n\nSo this patch is to resume async_read_until.",
      "parentUuid": "20b49ff9_192e06d7",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "abdddbad_9fd0af3c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-23T18:27:28Z",
      "side": 1,
      "message": "Sorry, I don\u0027t quite understand, the data showed is for normal/working case, right?  What is the reason that the callback is not called?",
      "parentUuid": "2fb937f2_9d7e99bb",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1e1c64b_eafe26a1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-23T19:01:08Z",
      "side": 1,
      "message": "\u003e I don\u0027t know.\n\nSounds like there\u0027s a better root cause needed here.\n\nasync_read_until isn\u0027t returning, which would imply that the kernel isn\u0027t returning which is expected here.  What is the kernel returning in this case?  Can we adjust to use the regular async_read instead and avoid this problem without timers?  Considering there are systems that have overloaded i2c busses, and there\u0027s not one timeout that will work for all systems, I\u0027m worried this patch as-written will break people.",
      "parentUuid": "20b49ff9_192e06d7",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7e8bf44_5c8e107c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-24T07:47:06Z",
      "side": 1,
      "message": "Personally, I don\u0027t there is no strong requirement to use async_read_until (it is used in the whole dbus-sensors repo), because all the data from sensor device just few bytes.\nHow about to change all the async_read_until to async_read in the whole dbus-sensor repo?",
      "parentUuid": "b1e1c64b_eafe26a1",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a33ff99d_18189a29",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-24T07:58:58Z",
      "side": 1,
      "message": "Correct typo.\n I don\u0027t think there is strong requirement to use async_read_until.",
      "parentUuid": "b7e8bf44_5c8e107c",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d973e1ea_33645b72",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-24T09:13:29Z",
      "side": 1,
      "message": "async_read function met the same issue ðŸ˜ž, cannot return to the callback function.",
      "parentUuid": "a33ff99d_18189a29",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eca12c42_784ed6d1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-24T10:09:35Z",
      "side": 1,
      "message": "sync read file is working well, like below. do you agree to use sync read file?\nI think it is acceptable, because the sensor data is small.\nActually we use it in updateMinMaxValues.\n\nvoid PSUSensor::setupRead(void)\n{\n    std::cerr \u003c\u003c \"setupRead: \" \u003c\u003c path\n                  \u003c\u003c \"\\n\";\n    std::string line;\n    std::ifstream sensorFile(path);\n    if (sensorFile.good())\n    {\n        try\n        {\n            std::getline(sensorFile, line);\n            rawValue \u003d std::stod(line);\n            sensorFile.close();\n            double nvalue \u003d rawValue / sensorFactor;\n\n            updateValue(nvalue);\n\n            if (minMaxReadCounter++ % 8 \u003d\u003d 0)\n            {\n                updateMinMaxValues();\n            }\n        }\n        catch (const std::invalid_argument\u0026)\n        {\n            std::cerr \u003c\u003c \"Could not parse \" \u003c\u003c line \u003c\u003c \"\\n\";\n            incrementError();\n        }\n    }\n    lseek(fd, 0, SEEK_SET);\n    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));\n\n    std::weak_ptr\u003cPSUSensor\u003e weakRef \u003d weak_from_this();\n    waitTimer.async_wait([weakRef](const boost::system::error_code\u0026 ec) {\n        std::shared_ptr\u003cPSUSensor\u003e self \u003d weakRef.lock();\n        if (ec \u003d\u003d boost::asio::error::operation_aborted)\n        {\n            std::cerr \u003c\u003c \"Failed to reschedule\\n\";\n            return;\n        }\n        if (self)\n        {\n            self-\u003esetupRead();\n        }\n    });\n    return;\n}",
      "parentUuid": "d973e1ea_33645b72",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a41ff786_49835d98",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-30T23:02:42Z",
      "side": 1,
      "message": "I agree sync read is probably fine most of time since the data is small. It also simplifies logic.\nBut it is a rather big shift. I would worry about it introduce new intermittent issues.\nSome load/stress testing may be needed. \nAnother option is to create this \"async read with timeout\" support like other io stream in boost.",
      "parentUuid": "eca12c42_784ed6d1",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2757335_49b0a87e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-31T21:14:09Z",
      "side": 1,
      "message": "Frankly, I don\u0027t care what this code is doing.  I want to understand why the kernel isn\u0027t returning, or, if it is, why the async_read_until isn\u0027t returning.  Once that is understood, we\u0027ll know if this is a kernel bug, or a boost bug, or an OpenBMC bug.\n\nAny root cause that involves \"when I change this X method with Y method, it works\" will not be accepted.  Both async_read_until, async_read, and read would be expected to work here.  If they don\u0027t we need to understand why, so we can get the other sensors updated as well.",
      "parentUuid": "a41ff786_49835d98",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c8fd193_abd82815",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-04-06T07:57:01Z",
      "side": 1,
      "message": "Sure, we have to root-cause it.\nAt least we found only asio async read has such issue, it is not stable as common sync call, so it is not correct way to use asio async read here.",
      "parentUuid": "a2757335_49b0a87e",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa2634ce_86f1e6d9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-04-07T11:23:08Z",
      "side": 1,
      "message": "You could below log message async_read_until is hang at \"Jan 01 00:30:24\" with error \"system:11\", as I know it is EAGAIN.\nSeems Asio don\u0027t handle it well or even return error code to call back function.\n\n\nJan 01 00:30:22 intel-obmc psusensor[458]: @asio|1822.391454|4328*4329|deadline_timer@0x14d9c88.async_wait\nJan 01 00:30:22 intel-obmc psusensor[458]: @asio|1822.391509|\u003c4328|\nJan 01 00:30:22 intel-obmc psusensor[458]: @asio|1822.391537|\u003e4327|ec\u003dsystem:125\nJan 01 00:30:22 intel-obmc psusensor[458]: @asio|1822.391565|\u003c4327|\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391476|\u003e4329|ec\u003dsystem:0\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391590|4329*4330|deadline_timer@0x14d9cc8.async_wait\nJan 01 00:30:23 intel-obmc psusensor[458]: setupRead /sys/class/hwmon/hwmon2/power1_input\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391682|4329^4331|in \u0027async_read_until\u0027 (/usr/src/debug/dbus-sensors/0.1+git999-r0/recipe-sysroot/usr/include/boost/asio/:878)\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391682|4329*4331|descriptor@0x14d9c5c.async_read_some\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391750|.4331|non_blocking_read,ec\u003dsystem:0,bytes_transferred\u003d10\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391778|\u003c4329|\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391803|\u003e4331|ec\u003dsystem:0,bytes_transferred\u003d10\nJan 01 00:30:23 intel-obmc psusensor[458]: async_read_until back /sys/class/hwmon/hwmon2/power1_input\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391851|4331|deadline_timer@0x14d9cc8.cancel\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391967|4331|deadline_timer@0x14d9c88.cancel\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.391997|4331*4332|deadline_timer@0x14d9c88.async_wait\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.392038|\u003c4331|\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.392060|\u003e4330|ec\u003dsystem:125\nJan 01 00:30:23 intel-obmc psusensor[458]: @asio|1823.392082|\u003c4330|\nJan 01 00:30:24 intel-obmc psusensor[458]: @asio|1824.392069|\u003e4332|ec\u003dsystem:0\nJan 01 00:30:24 intel-obmc psusensor[458]: @asio|1824.392174|4332*4333|deadline_timer@0x14d9cc8.async_wait\nJan 01 00:30:24 intel-obmc psusensor[458]: setupRead /sys/class/hwmon/hwmon2/power1_input\nJan 01 00:30:24 intel-obmc psusensor[458]: @asio|1824.392271|4332^4334|in \u0027async_read_until\u0027 (/usr/src/debug/dbus-sensors/0.1+git999-r0/recipe-sysroot/usr/include/boost/asio/:878)\nJan 01 00:30:24 intel-obmc psusensor[458]: @asio|1824.392271|4332*4334|descriptor@0x14d9c5c.async_read_some\nJan 01 00:30:24 intel-obmc psusensor[458]: @asio|1824.906478|.4334|non_blocking_read,ec\u003dsystem:11,bytes_transferred\u003d0\nJan 01 00:30:24 intel-obmc psusensor[458]: @asio|1824.906580|\u003c4332|\nJan 01 00:30:34 intel-obmc psusensor[458]: @asio|1834.392269|\u003e4333|ec\u003dsystem:0\nJan 01 00:30:34 intel-obmc psusensor[458]: Read timer timeout, resume it: /sys/class/hwmon/hwmon2/power1_input\nJan 01 00:30:34 intel-obmc psusensor[458]: @asio|1834.392397|4333|descriptor@0x14d9c5c.cancel\nJan 01 00:30:34 intel-obmc psusensor[458]: @asio|1834.392443|4333|deadline_timer@0x14d9cc8.cancel\nJan 01 00:30:34 intel-obmc psusensor[458]: @asio|1834.392466|4333*4335|deadline_timer@0x14d9cc8.async_wait\nJan 01 00:30:34 intel-obmc psusensor[458]: setupRead /sys/class/hwmon/hwmon2/power1_input",
      "parentUuid": "3c8fd193_abd82815",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 14
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c4ab034_3649f091",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-19T21:56:42Z",
      "side": 1,
      "message": "Seems like you are adding the timeout ability for the async_read_until function.\nDepends on what is the root cause of the timeout, can it happen on other descriptor read?\nIt might be beneficial to add a generic \"read with timeout\" function in utility.",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 12,
        "endChar": 55
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58cf5f1a_2410d8e0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "Are there any documented gaurantees in the kernel for this kind of thing?  I thought there were hwmon knobs for this kind of thing.",
      "parentUuid": "2c4ab034_3649f091",
      "range": {
        "startLine": 12,
        "startChar": 0,
        "endLine": 12,
        "endChar": 55
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "187bd833_102be2a8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2021-03-19T23:35:25Z",
      "side": 1,
      "message": "could?",
      "range": {
        "startLine": 15,
        "startChar": 11,
        "endLine": 15,
        "endChar": 15
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e5cb8cc_0d912077",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "This needs a better tested statement, as well as a better root cause.",
      "parentUuid": "187bd833_102be2a8",
      "range": {
        "startLine": 15,
        "startChar": 11,
        "endLine": 15,
        "endChar": 15
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6113fb85_e26c5b45",
        "filename": "include/PSUSensor.hpp",
        "patchSetId": 3
      },
      "lineNbr": 31,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-19T21:56:42Z",
      "side": 1,
      "message": "IMO - readTimeoutTimer is a better description of what the timer is for. Same in other places.",
      "range": {
        "startLine": 31,
        "startChar": 3,
        "endLine": 31,
        "endChar": 42
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c255e69_2f9dece6",
        "filename": "include/PSUSensor.hpp",
        "patchSetId": 3
      },
      "lineNbr": 31,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2021-03-19T23:35:25Z",
      "side": 1,
      "message": "Probably want to use steady_timer instead to avoid time change issues.",
      "range": {
        "startLine": 31,
        "startChar": 17,
        "endLine": 31,
        "endChar": 31
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8225309d_a158100c",
        "filename": "include/PSUSensor.hpp",
        "patchSetId": 3
      },
      "lineNbr": 31,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "Because waitTimer is not running when we\u0027re reading, we don\u0027t need a second timer here, just reuse waitTimer.",
      "parentUuid": "6113fb85_e26c5b45",
      "range": {
        "startLine": 31,
        "startChar": 3,
        "endLine": 31,
        "endChar": 42
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e8865ea_1a137a1f",
        "filename": "include/PSUSensor.hpp",
        "patchSetId": 3
      },
      "lineNbr": 31,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "6c255e69_2f9dece6",
      "range": {
        "startLine": 31,
        "startChar": 17,
        "endLine": 31,
        "endChar": 31
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74c89a4c_fd13dd94",
        "filename": "include/PSUSensor.hpp",
        "patchSetId": 3
      },
      "lineNbr": 31,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-22T02:04:54Z",
      "side": 1,
      "message": "Right could change all timers to steady_timer at one time.",
      "parentUuid": "8e8865ea_1a137a1f",
      "range": {
        "startLine": 31,
        "startChar": 17,
        "endLine": 31,
        "endChar": 31
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5b0acca_8e1d1b02",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2021-03-19T23:35:25Z",
      "side": 1,
      "message": "expires_from_now is deprecated in favor of expires_after. And might want to prefer std::chrono:: instead of boost::posix_time",
      "range": {
        "startLine": 134,
        "startChar": 14,
        "endLine": 134,
        "endChar": 57
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0a926a2a_f454d487",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "b5b0acca_8e1d1b02",
      "range": {
        "startLine": 134,
        "startChar": 14,
        "endLine": 134,
        "endChar": 57
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc93e699_f3940d83",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 137,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-19T21:56:42Z",
      "side": 1,
      "message": "move before it is used",
      "range": {
        "startLine": 137,
        "startChar": 8,
        "endLine": 137,
        "endChar": 61
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7d7ded8_27526f7d",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 137,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "needs nullptr checked.  This also should go below operation aborted.",
      "parentUuid": "cc93e699_f3940d83",
      "range": {
        "startLine": 137,
        "startChar": 8,
        "endLine": 137,
        "endChar": 61
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a10bec08_a37e9815",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 137,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-22T02:04:54Z",
      "side": 1,
      "message": "Checked it before using at line 142",
      "parentUuid": "a7d7ded8_27526f7d",
      "range": {
        "startLine": 137,
        "startChar": 8,
        "endLine": 137,
        "endChar": 61
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bf1ea45_fa29acd0",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 149,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-19T21:56:42Z",
      "side": 1,
      "message": "What ec will line 163 get? Currently, ec is not checked before it is passed to handleResponse(ec), please follow through to make sure it is handled correctly. Looks like setupRead can get called twice: line 150 and line 239.",
      "range": {
        "startLine": 149,
        "startChar": 12,
        "endLine": 149,
        "endChar": 36
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ec78feb4_ac556b04",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 149,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-03-20T18:14:51Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "8bf1ea45_fa29acd0",
      "range": {
        "startLine": 149,
        "startChar": 12,
        "endLine": 149,
        "endChar": 36
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88332bd0_0811986c",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 149,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-22T02:04:54Z",
      "side": 1,
      "message": "There is no twice called for setupRead.\nCorrect case: readTimer will be cancelled at line 168.\nIssue case, when async_read_until hang: readTimer will trigger setupRead instead of waitTimer.",
      "parentUuid": "ec78feb4_ac556b04",
      "range": {
        "startLine": 149,
        "startChar": 12,
        "endLine": 149,
        "endChar": 36
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e771c1f_1af3e782",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 149,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-22T18:59:14Z",
      "side": 1,
      "message": "I might be missing something, but here is the flow I see:\nafter line 149, line150 get called to setupRead.\nline149 will cause line161 lambda, which does not check ec and call line 170.\nCheck at line190 will fail (need to verify with actual ec was my original comment)\ncode continues and may end up calling at line 239.",
      "parentUuid": "88332bd0_0811986c",
      "range": {
        "startLine": 149,
        "startChar": 12,
        "endLine": 149,
        "endChar": 36
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86e7ccd3_108e5f17",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 149,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2021-03-23T02:32:04Z",
      "side": 1,
      "message": "Line149 is to cancel inputDev but not trigger line 161 lambda, also not the coming 170/190.",
      "parentUuid": "7e771c1f_1af3e782",
      "range": {
        "startLine": 149,
        "startChar": 12,
        "endLine": 149,
        "endChar": 36
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f7c2648d_0d45a7ea",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 149,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2021-03-23T18:27:28Z",
      "side": 1,
      "message": "According to the documentation, the handlers are getting called.\nhttps://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/reference/posix__basic_stream_descriptor/cancel/overload1.html",
      "parentUuid": "86e7ccd3_108e5f17",
      "range": {
        "startLine": 149,
        "startChar": 12,
        "endLine": 149,
        "endChar": 36
      },
      "revId": "369a10bce9a5a63538a3320f79672d147ba4c22a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}