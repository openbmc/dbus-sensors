{
  "comments": [
    {
      "key": {
        "uuid": "836c8bd9_c47fcdd6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-07T18:14:05Z",
      "side": 1,
      "message": "I don\u0027t see anything asyncronous about the current code.  It calls std::getline, which I\u0027m pretty sure is synchronous.",
      "range": {
        "startLine": 22,
        "startChar": 48,
        "endLine": 22,
        "endChar": 60
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5459e382_345b9d0c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-07T18:14:05Z",
      "side": 1,
      "message": "What does it mean to \"turn off\" a server power supply?",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb6d3e55_d859963c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 32,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2021-06-08T17:54:44Z",
      "side": 1,
      "message": "I will update this to read \"Remove AC input from PSU1\"",
      "parentUuid": "5459e382_345b9d0c",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e691b4a_1b4d63bb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 32,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-08T18:24:21Z",
      "side": 1,
      "message": "üëç",
      "parentUuid": "eb6d3e55_d859963c",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 32,
        "endChar": 13
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e46d6b5b_475d5326",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 126,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-07T18:12:25Z",
      "side": 1,
      "message": "This is a blocking call.  Why wouldn\u0027t we use boost::asio::async_read here?",
      "range": {
        "startLine": 126,
        "startChar": 0,
        "endLine": 126,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6d00dfa_e345c6c7",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 126,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2021-06-08T17:54:44Z",
      "side": 1,
      "message": "The original solution was using async_read_until, which was found to be unreliable.\nUsing async_read requires supplying a buffer and reading into that buffer. The problem is that requires apriori knowledge of the stream size, or you have to recreate a function that behaves like async_read_until.\n\nI have spent almost four weeks trying to resolve a defect saying that the PSU2 input power, output power, and output current do not update correctly. I am, subsequently, made aware that Kuiying has already submitted a solution (this commit) that always returns the correct data for PSU1 and PSU2. The solution shifted away from an unreliable collection method to one that is reliable.\n\nIn my opinion the original code with async_read_until was difficult to read and difficult to determine correctness. This code, which Kuiying submitted in patchset 4 or 5, is much easier to  determine the flow of the code, and the correctness of the code. It is unclear to me why an unreliable async method is preferable to a reliable synchronous method.\n\nAdditionally this same model is used in the PSUSubEvent setupRead code. It is also failing, as removing AC from PSU2 does not generate ACLost or PredictiveFailure events. It also occasionally decides that Failure will not be emitted either. The behavior of the events is erratic for both PSUs. PSU1 tends to work correctly, most of the time. After spending a few weeks in this portion of the code I still have no idea how it functions. The async method is making the code obtuse, and unreliable. Which is why I don\u0027t believe we should use it here.",
      "parentUuid": "e46d6b5b_475d5326",
      "range": {
        "startLine": 126,
        "startChar": 0,
        "endLine": 126,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43eebb4d_89fdad1a",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 126,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-08T18:24:21Z",
      "side": 1,
      "message": "\u003e The original solution was using async_read_until, which was found to be unreliable.\n\nAsync_read_until is what\u0027s currently on master.\n\n\u003e Using async_read requires supplying a buffer and reading into that buffer. The problem is that requires apriori knowledge of the stream size, or you have to recreate a function that behaves like async_read_until.\n\nI misspoke, I would expect we should use async_read_some, which does not require prior knowledge of the stream size.\n\n\u003e \n\u003e I have spent almost four weeks trying to resolve a defect saying that the PSU2 input power, output power, and output current do not update correctly. I am, subsequently, made aware that Kuiying has already submitted a solution (this commit) that always returns the correct data for PSU1 and PSU2. The solution shifted away from an unreliable collection method to one that is reliable.\n\nReliable in some contexts, but moves to blocking calls, which now makes every interface in the system slower and less reliable, because a hung power supply can now cause the daemon to stop responding to dbus requests.  This was what James found very early on in developing dbus-sensors, which is why I\u0027m somewhat hesitant to go back to blocking calls, given there was a very good reason we went away from blocking calls in the first place.  If we have solutions to all the problems we avoided, I\u0027m open to it, but I don\u0027t see this patchset proposing any new coding styles or doing any failure/performance testing, which makes me think that this wasn\u0027t considered;  If it has been, I apologize, lets get that documented.\n\nAlso, if you\u0027re blocking, there\u0027s no way to time out a read or interrupt the read, which is required in some contexts.  We\u0027d need solutions to those problems as well.\n\n\u003e \n\u003e In my opinion the original code with async_read_until was difficult to read and difficult to determine correctness. This code, which Kuiying submitted in patchset 4 or 5, is much easier to  determine the flow of the code, and the correctness of the code. It is unclear to me why an unreliable async method is preferable to a reliable synchronous method.\n\nBecause the failure modes matter.  When power supplies fail, the synchronous code can effectively cause all the external interfaces (IPMI and redfish) to lock up and time out, hence why this code is this way today.  I\u0027m open to the possibility that this is better, but I don\u0027t see any testing of those failure modes that this code handles today.\n\n\u003e \n\u003e Additionally this same model is used in the PSUSubEvent setupRead code. It is also failing, as removing AC from PSU2 does not generate ACLost or PredictiveFailure events.\n\nThat\u0027s a little bit surprising considering Kwin built and tested the code, presumably on the same system.  Kwin, is this the same behavior you\u0027re seeing, is it a regression, or is it specific to Jonathans setup?\n\n\u003e It also occasionally decides that Failure will not be emitted either. The behavior of the events is erratic for both PSUs. PSU1 tends to work correctly, most of the time. After spending a few weeks in this portion of the code I still have no idea how it functions. The async method is making the code obtuse, and unreliable. Which is why I don\u0027t believe we should use it here.",
      "parentUuid": "c6d00dfa_e345c6c7",
      "range": {
        "startLine": 126,
        "startChar": 0,
        "endLine": 126,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "822cc231_67b2da9e",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 126,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2021-06-08T19:26:09Z",
      "side": 1,
      "message": "\u003e \u003e The original solution was using async_read_until, which was found to be unreliable.\n\u003e \n\u003e Async_read_until is what\u0027s currently on master.\n\u003e \n\u003e \u003e Using async_read requires supplying a buffer and reading into that buffer. The problem is that requires apriori knowledge of the stream size, or you have to recreate a function that behaves like async_read_until.\n\u003e \n\u003e I misspoke, I would expect we should use async_read_some, which does not require prior knowledge of the stream size.\n\nI\u0027ll take a look and see if it can be molded to fit. I\u0027m worried about the comment in async_read_until docs that say you must guard against new async_read_xxx functions. I\u0027m not sure the code on master guards against that.\n\n\u003e \n\u003e \u003e \n\u003e \u003e I have spent almost four weeks trying to resolve a defect saying that the PSU2 input power, output power, and output current do not update correctly. I am, subsequently, made aware that Kuiying has already submitted a solution (this commit) that always returns the correct data for PSU1 and PSU2. The solution shifted away from an unreliable collection method to one that is reliable.\n\u003e \n\u003e Reliable in some contexts, but moves to blocking calls, which now makes every interface in the system slower and less reliable, because a hung power supply can now cause the daemon to stop responding to dbus requests.  This was what James found very early on in developing dbus-sensors, which is why I\u0027m somewhat hesitant to go back to blocking calls, given there was a very good reason we went away from blocking calls in the first place.  If we have solutions to all the problems we avoided, I\u0027m open to it, but I don\u0027t see this patchset proposing any new coding styles or doing any failure/performance testing, which makes me think that this wasn\u0027t considered;  If it has been, I apologize, lets get that documented.\n\nThanks for the backstory.\n\n\u003e \n\u003e Also, if you\u0027re blocking, there\u0027s no way to time out a read or interrupt the read, which is required in some contexts.  We\u0027d need solutions to those problems as well.\n\u003e \n\u003e \u003e \n\u003e \u003e In my opinion the original code with async_read_until was difficult to read and difficult to determine correctness. This code, which Kuiying submitted in patchset 4 or 5, is much easier to  determine the flow of the code, and the correctness of the code. It is unclear to me why an unreliable async method is preferable to a reliable synchronous method.\n\u003e \n\u003e Because the failure modes matter.  When power supplies fail, the synchronous code can effectively cause all the external interfaces (IPMI and redfish) to lock up and time out, hence why this code is this way today.  I\u0027m open to the possibility that this is better, but I don\u0027t see any testing of those failure modes that this code handles today.\n\nTo which failure modes are you referring?\nSomething more than AC removal, and PSU removal?\nPlus..... ugh.\n\n\u003e \n\u003e \u003e \n\u003e \u003e Additionally this same model is used in the PSUSubEvent setupRead code. It is also failing, as removing AC from PSU2 does not generate ACLost or PredictiveFailure events.\n\u003e \n\u003e That\u0027s a little bit surprising considering Kwin built and tested the code, presumably on the same system.  Kwin, is this the same behavior you\u0027re seeing, is it a regression, or is it specific to Jonathans setup?\n\u003e \n\u003e \u003e It also occasionally decides that Failure will not be emitted either. The behavior of the events is erratic for both PSUs. PSU1 tends to work correctly, most of the time. After spending a few weeks in this portion of the code I still have no idea how it functions. The async method is making the code obtuse, and unreliable. Which is why I don\u0027t believe we should use it here.",
      "parentUuid": "43eebb4d_89fdad1a",
      "range": {
        "startLine": 126,
        "startChar": 0,
        "endLine": 126,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f223087_3baec169",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 126,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-08T23:27:48Z",
      "side": 1,
      "message": "\u003e \u003e \u003e The original solution was using async_read_until, which was found to be unreliable.\n\u003e \u003e \n\u003e \u003e Async_read_until is what\u0027s currently on master.\n\u003e \u003e \n\u003e \u003e \u003e Using async_read requires supplying a buffer and reading into that buffer. The problem is that requires apriori knowledge of the stream size, or you have to recreate a function that behaves like async_read_until.\n\u003e \u003e \n\u003e \u003e I misspoke, I would expect we should use async_read_some, which does not require prior knowledge of the stream size.\n\u003e \n\u003e I\u0027ll take a look and see if it can be molded to fit. I\u0027m worried about the comment in async_read_until docs that say you must guard against new async_read_xxx functions. I\u0027m not sure the code on master guards against that.\n\nTechnically all the code guards against that, because we don\u0027t restart the poll timer until after the read is complete, so there\u0027s no possibility for the timer to expire before the read has finished.  We don\u0027t have an explicit lock, but the code is just structured that way.\n\nFor what it\u0027s worth, the rules for async_read_some are the same as the rules for async_read_until, so aside from the buffers it should be a drop in replacement.\n\n\u003e \n\u003e \u003e \n\u003e \u003e \u003e \n\u003e \u003e \u003e I have spent almost four weeks trying to resolve a defect saying that the PSU2 input power, output power, and output current do not update correctly. I am, subsequently, made aware that Kuiying has already submitted a solution (this commit) that always returns the correct data for PSU1 and PSU2. The solution shifted away from an unreliable collection method to one that is reliable.\n\u003e \u003e \n\u003e \u003e Reliable in some contexts, but moves to blocking calls, which now makes every interface in the system slower and less reliable, because a hung power supply can now cause the daemon to stop responding to dbus requests.  This was what James found very early on in developing dbus-sensors, which is why I\u0027m somewhat hesitant to go back to blocking calls, given there was a very good reason we went away from blocking calls in the first place.  If we have solutions to all the problems we avoided, I\u0027m open to it, but I don\u0027t see this patchset proposing any new coding styles or doing any failure/performance testing, which makes me think that this wasn\u0027t considered;  If it has been, I apologize, lets get that documented.\n\u003e \n\u003e Thanks for the backstory.\n\u003e \n\u003e \u003e \n\u003e \u003e Also, if you\u0027re blocking, there\u0027s no way to time out a read or interrupt the read, which is required in some contexts.  We\u0027d need solutions to those problems as well.\n\u003e \u003e \n\u003e \u003e \u003e \n\u003e \u003e \u003e In my opinion the original code with async_read_until was difficult to read and difficult to determine correctness. This code, which Kuiying submitted in patchset 4 or 5, is much easier to  determine the flow of the code, and the correctness of the code. It is unclear to me why an unreliable async method is preferable to a reliable synchronous method.\n\u003e \u003e \n\u003e \u003e Because the failure modes matter.  When power supplies fail, the synchronous code can effectively cause all the external interfaces (IPMI and redfish) to lock up and time out, hence why this code is this way today.  I\u0027m open to the possibility that this is better, but I don\u0027t see any testing of those failure modes that this code handles today.\n\u003e \n\u003e To which failure modes are you referring?\n\u003e Something more than AC removal, and PSU removal?\n\u003e Plus..... ugh.\n\nSomething like, bus gets hung (i2c clock stuck low) or bus has too much higher priority traffic for the multi-master arbitration to succeed (like on a PSU bus that\u0027s shared with ME polling very quickly).\n\nThose are the two scenarios I remember, but there might be more.\n\n\u003e \n\u003e \u003e \n\u003e \u003e \u003e \n\u003e \u003e \u003e Additionally this same model is used in the PSUSubEvent setupRead code. It is also failing, as removing AC from PSU2 does not generate ACLost or PredictiveFailure events.\n\u003e \u003e \n\u003e \u003e That\u0027s a little bit surprising considering Kwin built and tested the code, presumably on the same system.  Kwin, is this the same behavior you\u0027re seeing, is it a regression, or is it specific to Jonathans setup?\n\u003e \u003e \n\u003e \u003e \u003e It also occasionally decides that Failure will not be emitted either. The behavior of the events is erratic for both PSUs. PSU1 tends to work correctly, most of the time. After spending a few weeks in this portion of the code I still have no idea how it functions. The async method is making the code obtuse, and unreliable. Which is why I don\u0027t believe we should use it here.",
      "parentUuid": "822cc231_67b2da9e",
      "range": {
        "startLine": 126,
        "startChar": 0,
        "endLine": 126,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d27b40d5_c119322c",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 129,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2021-06-07T18:01:33Z",
      "side": 1,
      "message": "Looks like it is global errno. \nCan you tell me which file include brings it here ? I am not able to find.",
      "range": {
        "startLine": 129,
        "startChar": 12,
        "endLine": 129,
        "endChar": 18
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da726d06_eeb18d2b",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 129,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-07T18:11:27Z",
      "side": 1,
      "message": "It\u0027s a global, but I\u0027m not following why we need it.  We don\u0027t seem to be doing anything that would set an errno.  std::stod is going to throw an exception on failure.",
      "parentUuid": "d27b40d5_c119322c",
      "range": {
        "startLine": 129,
        "startChar": 12,
        "endLine": 129,
        "endChar": 18
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2eb4c329_7efe1dc3",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 130,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2021-06-07T18:01:33Z",
      "side": 1,
      "message": "It can throw exception, right ? Does it need to be under try-catch block ?\nhttps://en.cppreference.com/w/cpp/string/basic_string/stof",
      "range": {
        "startLine": 130,
        "startChar": 23,
        "endLine": 130,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e383d96c_9b5b3023",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 130,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-07T18:11:27Z",
      "side": 1,
      "message": "Please use std::from_chars.",
      "parentUuid": "2eb4c329_7efe1dc3",
      "range": {
        "startLine": 130,
        "startChar": 23,
        "endLine": 130,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa2208a0_b29a0544",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 130,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2021-06-08T17:54:44Z",
      "side": 1,
      "message": "GCC does not support the double\u0026 version of the call.\n\nIn addition I was trying to get away from a try/catch, as the use of exceptions is undesirable. Am I misunderstanding, and that is primarily a BMCWeb rule?",
      "parentUuid": "e383d96c_9b5b3023",
      "range": {
        "startLine": 130,
        "startChar": 23,
        "endLine": 130,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d57d87b1_cc9b3066",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 130,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-08T18:24:21Z",
      "side": 1,
      "message": "\u003e GCC does not support the double\u0026 version of the call.\n\nDamn, so right you are......  I thought it had been at the same time as the others.  My bad, fine as is.\n\n\u003e \n\u003e In addition I was trying to get away from a try/catch, as the use of exceptions is undesirable. Am I misunderstanding, and that is primarily a BMCWeb rule?\n\nYes, exceptions are avoided in bmcweb because 99% of bmcweb failures happen in a connection context where the errors can be properly handled by either returning an error code to the user, or closing the connection.  bmcweb does use exceptions for startup issues that are fatal, but there\u0027s very few things that are unrecoverable in a webserver..\n\n\ndbus-sensors doesn\u0027t really have this issue, it can crash without any negative impact to the user (IPMI and bmcweb can both continue and return proper error codes) so exceptions are ok here.\n\nI\u0027m ok if we don\u0027t want to catch this one;  If the kernel is returning a valid code but isn\u0027t obeying its well defined API, it\u0027s fine to throw an exception and crash.",
      "parentUuid": "fa2208a0_b29a0544",
      "range": {
        "startLine": 130,
        "startChar": 23,
        "endLine": 130,
        "endChar": 39
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6304d361_7acb996d",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 145,
      "author": {
        "id": 1000418
      },
      "writtenOn": "2021-06-07T18:01:33Z",
      "side": 1,
      "message": "Not required. RAII takes care.",
      "range": {
        "startLine": 145,
        "startChar": 7,
        "endLine": 145,
        "endChar": 23
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cca21587_b351eb18",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 145,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-07T18:11:27Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "6304d361_7acb996d",
      "range": {
        "startLine": 145,
        "startChar": 7,
        "endLine": 145,
        "endChar": 23
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43ba1fcb_72392b4a",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 145,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2021-06-08T17:54:44Z",
      "side": 1,
      "message": "Not required. It isn\u0027t harmful either.\nIs the guidance of reducing the scope/duration of file open/close pairing passe?\nIf RAII is the preferred method, then should the sensorFile object be placed inside an anonymous block in order for it to close prior to the lseek and timer re-init?",
      "parentUuid": "cca21587_b351eb18",
      "range": {
        "startLine": 145,
        "startChar": 7,
        "endLine": 145,
        "endChar": 23
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de3cb8e0_9af6146d",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 145,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-08T18:24:21Z",
      "side": 1,
      "message": "\u003e Not required. It isn\u0027t harmful either.\n\u003e Is the guidance of reducing the scope/duration of file open/close pairing passe?\n\u003e If RAII is the preferred method, then should the sensorFile object be placed inside an anonymous block in order for it to close prior to the lseek and timer re-init?\n\nIdeally, yes, but in this case the exact destruction order isn\u0027t super critical, so it\u0027s fine either way.",
      "parentUuid": "43ba1fcb_72392b4a",
      "range": {
        "startLine": 145,
        "startChar": 7,
        "endLine": 145,
        "endChar": 23
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06daa1f7_b251980b",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 182,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-07T18:11:27Z",
      "side": 1,
      "message": "This looks unrelated to this patch.  Maybe put in a different patch?",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 182,
        "endChar": 1
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "119ebeff_f9ca4f25",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 182,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2021-06-08T17:54:44Z",
      "side": 1,
      "message": "This is git-diff failing to recognize the code block was not actually modified.\nSee earlier in the commit diff history above.",
      "parentUuid": "06daa1f7_b251980b",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 182,
        "endChar": 1
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28dea0dc_2f99ba68",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 182,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2021-06-08T18:24:21Z",
      "side": 1,
      "message": "Can you elaborate a little?  I\u0027m comparing base (ie master) to patchset 9, in which this diff shows these lines were added.  I suspect there was a merge conflict that didn\u0027t get handled well, and this diff ended up here?",
      "parentUuid": "119ebeff_f9ca4f25",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 182,
        "endChar": 1
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4085a101_de0e346b",
        "filename": "src/PSUSensor.cpp",
        "patchSetId": 9
      },
      "lineNbr": 182,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2021-06-08T19:26:09Z",
      "side": 1,
      "message": "Check this commit at line 150, you will see updateMinMaxValues there.\nThis code is not new, only moved.",
      "parentUuid": "28dea0dc_2f99ba68",
      "range": {
        "startLine": 170,
        "startChar": 0,
        "endLine": 182,
        "endChar": 1
      },
      "revId": "2f561de79f3f3616c642e2f5b2a924ea3b5d3db6",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    }
  ]
}